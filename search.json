[{"title":"拓扑排序","url":"/2021/10/29/拓扑排序/","content":"\n先后关系，层级关系。\n\n<!--more-->\n\n# 层级关系\n\n若一个问题中存在层级关系，即只能层级低到层级高。\n那么我们可以视为其是一种拓扑排序，可以由层级低的向层级高的建边。\n\n## 例题 [P1983 [NOIP2013 普及组] 车站分级](https://www.luogu.com.cn/problem/P1983)\n\n题意：一条单向的铁路线上，依次有编号为 1, 2, …, n1,2,…,n的 nn个火车站。每个火车站都有一个级别，最低为 11 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 xx，则始发站、终点站之间所有级别大于等于火车站xx 的都必须停靠。（注意：起始站和终点站自然也算作事先已知需要停靠的站点）现有 mm 趟车次的运行情况（全部满足要求），试推算这nn 个火车站至少分为几个不同的级别。\n\n思路：很明显的拓扑排序，那么层级低的向层级高的建边即可。最后求出有多少层。\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-29 14:13:02\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=1e3+11;\nll gra[maxn][maxn],is[maxn],dr[maxn],vis[maxn];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ans=0;\n    ll n,m;cin>>n>>m;\n    ll st[maxn],top;\n    for(ll i=1;i<=m;i++){\n        memset(is,0,sizeof(is));\n        ll s;cin>>s;\n        for(ll j=0;j<s;j++){\n            cin>>st[j];\n            is[st[j]]=1;\n        }\n        for(ll j=st[0];j<=st[s-1];j++){\n            if(!is[j]){\n                for(ll k=0;k<s;k++){\n                    if(!gra[j][st[k]])  gra[j][st[k]]=1,dr[st[k]]++;\n                }\n            }\n        }\n    }\n    do{\n        top=0;\n        for(ll i=1;i<=n;i++)  if(dr[i]==0 && !vis[i])  vis[i]=1,st[top++]=i;\n        for(ll i=0;i<top;i++){\n            for(ll j=1;j<=n;j++){\n                if(gra[st[i]][j]){\n                    gra[st[i]][j]=0,dr[j]--;\n                }\n            }\n        }\n        ans++;\n    }while(top);\n    cout<<ans-1<<endl;\n    return 0;\n}\n\n```\n","tags":["图论"]},{"title":"差分","url":"/2021/10/26/差分/","content":"\n差分 & 前缀和\n\n<!--more-->\n\n前缀和的差分为原序列\n差分的前缀和为原序列\n\n# 用差分实现区间操作\n\n给定一个长度为n的数列a，要求支持操作add(L,R,k)表示对a[ L ]~a[ R ]的每个数都加上k。并求修改后的序列a。\n\n我们考虑用差分的做法。这里 需要一个数组c，c用来记录某一个位置相对于前一个位置的改变量。我们对[L,R]区间进行加值操作，在c[L]处加一个k，在c[R+1]处就减去一个k。最后求序列的每个位置变成了多少，只需要求一下c数组的前缀和即可得到a。\n\n# 例题 \n\n[Mod, Xor and Everything HDU - 6275 ](https://vjudge.net/problem/HDU-6275)\n\n![](/uploads/差分/2021-10-26-20-17-12.png)\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-26 20:08:49\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=1e5+11;\nconst ll mod=998244353;\nll f2[maxn],f3[maxn],sum2[maxn],sum3[maxn];\nll qpow(ll b,ll p){\n    ll ans=1;\n    while(p){\n        if(p&1)  ans=ans*b%mod;\n        p>>=1;\n        b=b*b%mod;\n    }\n    return ans;\n}\nint main(){\n    ll ca;scanf(\"%lld\",&ca);\n    while(ca--){\n        memset(f2,0,sizeof(f2));memset(f3,0,sizeof(f3));\n        ll n,m;scanf(\"%lld%lld\",&n,&m);\n        for(ll i=1;i<=m;i++){\n            ll x,y,type;scanf(\"%lld%lld%lld\",&x,&y,&type);\n            if(type==2)  f2[x]++,f2[y+1]--;\n            else  f3[x]++,f3[y+1]--;\n        }\n        ll ans2=INF,ans3=INF;\n        sum2[0]=sum3[0]=0;\n        for(ll i=1;i<=n;i++){\n            sum2[i]=sum2[i-1]+f2[i];\n            ans2=min(ans2,sum2[i]);\n            sum3[i]=sum3[i-1]+f3[i];\n            ans3=min(ans3,sum3[i]);\n        }\n        if(ans2==INF)  ans2=0;\n        if(ans3==INF)  ans3=0;\n        ll ans=qpow(2,ans2)*qpow(3,ans3)%mod;\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n```\n\n\n\n","tags":["基本算法"]},{"title":"读入","url":"/2021/10/26/读入/","content":"\n注意读入 卡读入！\n\n<!--more-->\n\nATK+10.00\nATK Rate+10%\n\n要求处理出'+'之前的字符串以及'+'后的数字，不要%号。\n处理像这样的读入\n可以用getline一行行读，然后把不需要的字符替换为空格或是换行符，比如这里把'+'处理成换行符,'%'处理为空格。","tags":["基本算法"]},{"title":"数学+树状数组","url":"/2021/10/25/数学-树状数组/","content":"\n[Master of Sequence](https://acm.hdu.edu.cn/showproblem.php?pid=6274)\n\n![](/uploads/数学-树状数组/2021-10-25-20-22-05.png)\n`\n`\n`\n`\n`\n`\n`\n\n`\n`\n`\n\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n\n`\n`\n`\n`\n这是个向下取整求和问题。\n不难想到，应该二分t，但复杂度是O(n*logn)的，有m次询问，总共是O(m * n * logn)。即使给了10s，但是由于hdu的评测机实在不行，\n6e9居然10s也跑不完。。，所以得优化一下。这道题需要注意到ai范围只有1000，所以我们可以把相同的ai值一起来求和，优化复杂度。\n对于相同的ai值求和，即向下取整求和，关键是处理这个模数问题。所以我们把式子的模数处理出来，[ t-bi/ai ]化为[ k1 * ai+t%ai - ( k2 * ai+bi%ai )/ai ]。\n即k1-k2+[ (t%ai-bi%ai)/ai ]，记k1=t/ai,k2=bi/ai,c1=t%ai,c2=bi%ai,[ ( c1-c2 )/ai ]当且仅当c1 < c2时为-1，否则为0.故我们只需要每次统计 分母为ai时大于c1的c2个数即可.于是我们用f[ x ][ y ]表示当ai为x时，1 <=bi%ai+1<=y的bi个数。用树状数组来维护这个区间和即可。ai==x的个数就为f[ x ][ 1000 ]。\n于是答案就为: \n\n![](/uploads/数学-树状数组/2021-10-25-20-40-16.png)\n\nsum为ai==i从1~1000，bi/ai的和。\n\n踩坑：因为树状数组左端点不能为0，不然update会死循环，但是bi%ai可以为0，所以我们统一将bi%ai+1.\n踩坑：一开始没用num[ i ]统计ai为i时，ai的个数，用的时getsum(1000)超时了，改了之后是时间限制的一半，怪不得会超时。常数大了。\n\n```cpp\n//两个错误,bi/ai弄错了\n//bi%ai在树状数组中不能存0\n//getsum()多写了几个超时了... 醉了  \n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-25 20:49:09\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=1e5+11;\n\nll f[1111][1111],a[maxn],b[maxn],num[1111];\nll n,m,sum;\n\nll lowbit(ll x){return x & -x;}\nvoid update(ll i,ll x,ll val){for(;x<=1000;f[i][x]+=val,x+=lowbit(x));}\n//update,x为0时死循环\n\nll getsum(ll i,ll x){ll sum=0;for(;x>=1;sum+=f[i][x],x-=lowbit(x));return sum;}\n\nll check(ll mid,ll k){\n    ll ans=0;\n    for(ll i=1;i<=1000;i++){\n        ans=ans+mid/i*num[i];\n        ans=ans-num[i]+getsum(i,mid%i+1);\n    }\n    ans-=sum;\n    if(ans>=k)  return 1;\n    else  return 0;\n}\n\nvoid solve(ll k){\n    ll l=0,r=1e9+11;\n    while(l<r){\n        ll mid=(l+r)/2;\n        if(check(mid,k))  r=mid;\n        else  l=mid+1;\n    }\n    printf(\"%lld\\n\",l);\n}\n\nint main(){\n    ll ca;scanf(\"%lld\",&ca);\n    while(ca--){\n        memset(f,0,sizeof(f));memset(num,0,sizeof(num));\n        sum=0;\n        scanf(\"%lld%lld\",&n,&m);\n        for(ll i=1;i<=n;i++)  scanf(\"%lld\",&a[i]);\n        for(ll i=1;i<=n;i++){\n            scanf(\"%lld\",&b[i]);\n            sum+=b[i]/a[i];\n            update(a[i],b[i]%a[i]+1,1);\n            num[a[i]]++;\n        }\n        for(ll i=1;i<=m;i++){\n            ll type;scanf(\"%lld\",&type);\n            if(type==1){\n                ll x,y;scanf(\"%lld%lld\",&x,&y);\n                sum-=b[x]/a[x];\n                sum+=b[x]/y;\n                update(a[x],b[x]%a[x]+1,-1);\n                num[a[x]]--;\n                update(y,b[x]%y+1,1);\n                num[y]++;\n                a[x]=y;\n            }\n            else if(type==2){\n                ll x,y;scanf(\"%lld%lld\",&x,&y);\n                sum-=b[x]/a[x];\n                sum+=y/a[x];\n                update(a[x],b[x]%a[x]+1,-1);\n                num[a[x]]--;\n                update(a[x],y%a[x]+1,1);\n                num[a[x]]++;\n                b[x]=y;\n            }\n            else{\n                ll k;scanf(\"%lld\",&k);\n                solve(k);\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["数据结构","数学","好题"]},{"title":"贪心思维","url":"/2021/10/25/贪心思维/","content":"\n[Neko's loop HDU - 6444](https://vjudge.net/problem/HDU-6444)\n\n题意：有n个城市, 在每个城市中你可以选择花费a[ i ]的价格买一个能量块, 也可以选择以a[ i ]的价格卖出一个能量块(前提是你要有能量块可以卖). 你会从1号城市依次走到n号城市, 每次可以选择买或者卖或者什么也不做. 在初始你有无限多的钱的前提下, 问你能获得的最大利润, 以及在最大利润的前提下最小的买卖次数.\n————————————————\n版权声明：本文为CSDN博主「逍遥Fau」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_45799835/article/details/108682519\n\n·\n·\n\n·\n·\n·\n·\n·\n·\n·\n\n·\n·\n·\n·\n·\n\n·\n·\n\n·\n·\n·\n·\n·\n\n·\n·\n·\n·\n·\n\n·\n解题思路:\n首先如果一件物品买了后再卖了能赚钱, 则我们一定会采取这种方案, 因为题目要求最大利润优先, 最小的买卖次数则是不做无意义的买卖, 如花费x元购买能量块后又以x元卖出.\n\n贪心思路:\n因为我们难以决定在第i个城市我们采取怎么样的操作是最优的, 所以不妨对于每一个城市, 我们都认为我们可以从该城市买入能量块, 并且在j城市(j>i)卖出(但是在卖出之前, 我们认为我们在i城市什么也没做). 而j城市的能量块价格是一定为a[j]的, 所以此时我们如果要卖出能量块, 一定要以最小的价格在i城市买入能量块. 对于买入能量块的城市i, 我们可以采用小顶堆来维护, 而城市j的确定则是难点.\n\n假设我们现在存在一个小顶堆, 里面存放的元素代表可以用x的价格买入能量块(即所有的i城市), 当我们到达j城市, 此时如果满足a[j] > heap.top(), 我们此时选择卖出一定可以赚到钱, 且为一种优质策略.\n此时我们的利润变化为: res = res + a[j] - x. (记为*式)\n\n但是我们无法保证后续不会存在城市k (k>j), 满足a[k] > a[j], 则我们发现不如在k城市卖出刚才的能量块, 所以我们此时就要有一种反悔策略, 即: 刚才的能量块不选择在j城市卖出(即我们又可以以a[j]的价格买入能量块, 应当把a[j]入堆), 而在k城市卖出该能量块. 本身我们花费了x元买入, 卖出得到了a[j]元, 变成了x元买入, a[k]元卖出. 则利润变化为: res = res - a[j] + a[k]. 做一个变形, 类比于*式, 我们得到 res = res + a[k] - a[j].\n从操作次数的角度看, 我们在j城市买入能量块, 在k城市卖出, 结合之前i城市的操作, 相当于我们在j城市卖了一次, 又买了一次. 所以在j城市的操作并不是合法操作, 不应计算在结果中.\n\n而从利润的角度看, 我们获得的利润可以看作买了i, 在j卖出, 又在j买入, 在k卖出. 我们发现这两种情况的利润遵循相同的公式.\n————————————————\n版权声明：本文为CSDN博主「逍遥Fau」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_45799835/article/details/108682519\n\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:37\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-25 13:07:14\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca;cin>>ca;\n    while(ca--){\n        ll n;cin>>n;\n        priority_queue<ll,vector<ll>,greater<ll>> q;\n        map<ll,ll> mp;\n        ll ans=0,cnt=0;\n        for(ll i=1;i<=n;i++){\n            ll x;cin>>x;\n            if(!q.empty() && q.top()<x){\n                ll sell=q.top();q.pop();\n                ans+=x-sell;\n                if(mp.count(sell)){\n                    if(--mp[sell]==0)  mp.erase(sell);\n                    q.push(sell);\n                }\n                else  cnt++;\n                mp[x]++;\n            }\n            q.push(x);\n        }\n        cout<<ans<<\" \"<<cnt*2<<endl;\n    }\n    return 0;\n}\n\n```","tags":["思维","好题","贪心"]},{"title":"树状数组+DP","url":"/2021/10/24/树状数组-DP/","content":"\n\n[YJJ's Salesman](https://acm.hdu.edu.cn/showproblem.php?pid=6447)\n\n题意：A从(0,0)走到(1e9,1e9)，规定只能向下走，向右走，向右下走。在二维平面上有n < 1e5个村庄，\n每个村庄有一个奖励值，规定只有从左上方向来到达村庄方可获得奖励值，问最多可以获得多少奖励值。\n\n`\n`\n`\n`\n\n\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n\n`\n`\n`\n`\n`\n`\n`\n`\n很显然有DP[ i ][ j ]=DP[i-1][j]+DP[i][j-1]+DP[i-1][j-1];\n但是这需要DP[1e5][1e5]才可以操作，显然不行。\n于是我们考虑只遍历每个点。\n\n踩坑：DP更新的时候，只能从右往左更新，因为它是要求从左上方下来才可以，这样子就不包含从左来的点。如果从左往右更新，那么就包含了从左来的点。\n\n![](/uploads/树状数组-DP/2021-10-24-21-22-40.png)\n\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-24 21:17:24\n*/\n//优化遍历问题\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=1e5+11;\nstruct Point{\n    ll x,y,w;\n    bool operator < (const Point &b) const {\n        if(y==b.y)  return x>b.x;//需要从右向左更新\n        return y<b.y;\n    }\n}p[maxn];\nll f[maxn],x[maxn];\nll n;\n\nll lowbit(ll x){return x & -x;}\n\nvoid update(ll x,ll val){\n    for(;x<=n;f[x]=max(val,f[x]),x+=lowbit(x));\n}\n\nll query(ll x){\n    ll ans=0;\n    for(;x>=1;ans=max(ans,f[x]),x-=lowbit(x));\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca;cin>>ca;\n    while(ca--){\n        memset(f,0,sizeof(f));\n        cin>>n;\n        for(ll i=1;i<=n;i++){\n            ll y,w;cin>>x[i]>>y>>w;\n            p[i]={x[i],y,w};\n        }\n        sort(p+1,p+n+1);\n        sort(x+1,x+n+1);\n        ll l=unique(x+1,x+n+1)-(x+1);\n        for(ll i=1;i<=n;i++){\n            p[i].x=lower_bound(x+1,x+l+1,p[i].x)-x;\n        }    \n        for(ll i=1;i<=n;i++){\n            ll uu=query(p[i].x-1)+p[i].w;\n            update(p[i].x,uu);\n        }\n        cout<<query(l)<<endl;    \n    }\n    return 0;\n}\n\n```","tags":["数据结构","好题","DP"]},{"title":"小学数学","url":"/2021/10/24/小学数学/","content":"\n[Find Integer](https://acm.hdu.edu.cn/showproblem.php?pid=6441)\n\n![](/uploads/小学数学/2021-10-24-19-55-22.png)\n\n\n``\n\n`\n`\n`\n``\n\n`\n`\n`\n`\n`\n`\n`\n`\n\n`\n`\n`\n`\n`\n`\n`\n`\n\n`\n`\n`\n用费马大定理可证n > 2的时候无解。\n打表也可以发现此规律\nn==2的时候，a * a=(c-b) * (c+b);\n让c-b==1  和c-b==2，\n分a奇偶讨论即可。\n","tags":["数学"]},{"title":"树上结点对路径和","url":"/2021/10/24/树上结点对路径和/","content":"\n\n[Tree and Permutation](https://acm.hdu.edu.cn/showproblem.php?pid=6446)\n\n题意：一棵树有n < 1e5个点，每条边有个权值，n个点全排列，若每个排列为a1,a2.....an,\n则每个排列的值为(a1,a2),(a2,a3).....(an-1,an)的和，括号表示两点路径值，求所有排列值的和。\n\n`\n`\n`\n\n`\n`\n`\n`\n`\n`\n`\n`\n\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n思路：公式不难推出为2*(n-1)!*Dis。Dis为所有结点对的路径和。\n直接求Dis，因为有1e5*1e5对，不可。我们转而考虑求每条边的贡献。\n每条边连接两个连通块，设两个连通块点数分别为a,b。那么a * b 即为此边的贡献次数。\n遍历每条边即可。\n\n\n```cpp\n/*** \n * @Practice Win\n * 洛谷 P3379 【模板】最近公共祖先（LCA）\n */\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff//10^9级别，不到2^32\ntypedef long long ll;\nconst ll maxn=2e5+11;\nconst ll mod=1e9+7;\nstruct Edge{\n\tll to,w,nx;\n}e[maxn];\nll head[maxn],f[maxn];\nll tmp,cnt,n,ans;\n\nvoid init(){\n\tmemset(head,0,sizeof(head));\n\ttmp=2;cnt=1;ans=0;\n}\n\nvoid add(ll u,ll v,ll w){\n\te[tmp]={v,w};e[tmp].nx=head[u];head[u]=tmp++;\n}\nll dfs(ll u,ll fu){\n\tll sum=1;\n\tfor(ll i=head[u];i;i=e[i].nx){\n\t\tll v=e[i].to,w=e[i].w;\n\t\tif(v!=fu){\n\t\t\tll a=dfs(v,u);\n\t\t\tsum=sum+a;\n\t\t\tans=(ans+(a*(n-a)%mod)*w%mod)%mod;\n\t\t}\n\t}\n\treturn sum;\n}\nvoid solve(){\n\tdfs(1,0);\n\t//cout<<ans<<endl;\n\tans=(ans*f[n-1])*2%mod;\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\t// cin\n\t// cout\n    f[0]=1;\n    for(ll i=1;i<maxn;i++){\n    \tf[i]=f[i-1]*i%mod;\n    }\n    while(scanf(\"%lld\",&n)==1){\n    \tinit();\n    \tfor(ll i=1;i<=n-1;i++){\n    \t\tll u,v,w;\n    \t\tscanf(\"%lld%lld%lld\",&u,&v,&w);\n    \t\tadd(u,v,w);add(v,u,w);\n    \t}\n    \tsolve();\n    \t//printf(\"%lld\\n\",tmp);\n    }\n    return 0;\n}\n\n```","tags":["数据结构","思维","数学"]},{"title":"思维+数学","url":"/2021/10/21/思维-数学/","content":"\n[Sky Garden](https://vjudge.net/problem/Gym-102900I)\n\n题意，给n < 500个以原点为圆心的等间距圆，被m < 500条过圆心的直线均分，其中圆和直线以及直线和直线的交点构成了一个点集，问点集内的两两最短距离的和是多少（其中最短距离只能是从直线或圆上走出来的）。\n\n·\n·\n·\n·\n·\n··\n·\n·\n·\n··\n\n··\n·\n·\n·\n·\n·\n·\n·\n·\n·\n\n··\n·\n·\n·\n\n思路：\n不难证明和发现，从a到b，要么走线段+圆弧，要么就是两个线段。\n然后这道题就可以暴力莽过去了。\n也可以优化到n方。\n对于一个圆，分点在圆上和在圆内考虑。\n踩坑：这道都是浮点数的题，一个浮点数公式，写了a/2 * b * c，a为整形，b,c为浮点型，发生了整形截断，错了。\n\n\n这道题让我知道，若求和可以用公式化简，就可以不用循环求和，优化复杂度。\n还有就是这道题，O(1),O(n),O(n方)的运行时间几乎都没有区别。\n\n\nn方做法：\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-21 16:52:25\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nconst ld pi=acos(-1);\nll n,m;\nvoid solve(){\n    ld ans=0;\n    if(m==1){\n        ans=1.0/6.0*(2*n+2)*(2*n+1)*(2*n)-n*(n+1);//此处推公式可以用到裂项相消法\n        printf(\"%.10Lf\\n\",ans);\n        return ;\n    }\n    for(ld r2=1;r2<=n;r2++){\n        //圆内:\n        ld ans1=0;\n        for(ld i=1;i<=m-1;i++){\n            if(i*pi*r2/m<2*r2){\n                ans1=ans1+r2*(r2-1.0)/2.0*(i*pi/m+1);\n            }\n            else{\n                ans1=ans1+3*r2/2.0*(r2-1);// /2出错\n            }\n        }  \n        ans1=ans1*2;\n        ans1=ans1+r2*(2*r2-1);\n        ans1=ans1*2*m;\n        ans+=ans1;\n        //圆上：\n        ld ans2=0;\n        for(ld i=1;i<=m-1;i++){\n            ans2+=min(i*pi*r2/m,(ld)2*r2);\n        }\n        ans2=ans2*2+2*r2;\n        ans=ans+ans2*2*m/2.0;\n    }\n    printf(\"%.10Lf\\n\",ans);\n}\nint main(){\n    cin>>n>>m;\n    solve();\n    return 0;\n}\n```\n\nO(n)  做法：\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-21 18:07:32\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nconst ld pi=acos(-1);\nld n,m;\nvoid solve(){\n    ld ans=0;\n    if(m==1){\n        ans=1.0/6.0*(2*n+2)*(2*n+1)*(2*n)-n*(n+1);\n        printf(\"%.10Lf\\n\",ans);\n        return ;\n    }\n    ld ans1=0,ans2=0;\n    for(ld i=1;i<=m-1;i++){\n        if(i*pi/m<2){\n            ans1=ans1+1.0/6.0*(n+1)*n*(n-1)*(i*pi/m+1);\n            ans2=ans2+i*pi/m;\n        }\n        else{\n            ans1=ans1+1.0/2.0*(n+1)*n*(n-1);\n            ans2=ans2+2.0;\n        }\n    }\n    ans1*=2;\n    ans1=ans1+n*(n+1)*(4*n-1)/6.0;\n    ans=ans+ans1*2*m;\n\n    ans2=ans2*2+2;\n    ans2*=m;\n    ans=ans+ans2*n*(n+1.0)/2.0;\n\n\n    // for(ld r2=1;r2<=n;r2++){\n    //     //圆内:\n    //     ld ans1=0;\n    //     for(ld i=1;i<=m-1;i++){\n    //         if(i*pi*r2/m<2*r2){\n    //             ans1=ans1+r2*(r2-1.0)/2.0*(i*pi/m+1);\n    //         }\n    //         else{\n    //             ans1=ans1+3*r2/2.0*(r2-1);// /2出错\n    //         }\n    //     }  \n    //     ans1=ans1*2;\n    //     ans1=ans1+r2*(2*r2-1);\n    //     ans1=ans1*2*m;\n    //     ans+=ans1;\n    //     //圆上：\n    //     ld ans2=0;\n    //     for(ld i=1;i<=m-1;i++){\n    //         ans2+=min(i*pi*r2/m,(ld)2*r2);\n    //     }\n    //     ans2=ans2*2+2*r2;\n    //     ans=ans+ans2*2*m/2.0;\n    // }\n    printf(\"%.10Lf\\n\",ans);\n}\nint main(){\n    cin>>n>>m;\n    solve();\n    return 0;\n}\n\n\nO(1)做法：\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-21 18:25:51\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nconst ld pi=acos(-1);\nld n,m;\nvoid solve(){\n    ld ans=0;\n    if(m==1){\n        ans=1.0/6.0*(2*n+2)*(2*n+1)*(2*n)-n*(n+1);\n        printf(\"%.10Lf\\n\",ans);\n        return ;\n    }\n    ld ans1=0,ans2=0;\n    ld x=floor(2.0*m/pi),y=ceil(2.0*m/pi);\n    ans1=((1.0+x)*x/2.0*pi/m+x)*(n+1)*n*(n-1)/6.0;\n    ans1=ans1+1.0/2.0*(n+1)*n*(n-1)*(m-1-y+1.0);\n\n    ans2=(1.0+x)*x/2.0*pi/m;\n    ans2=ans2+2.0*(m-1-y+1.0);\n\n    // for(ld i=1;i<=m-1;i++){\n    //     if(i*pi/m<2){\n    //         ans1=ans1+1.0/6.0*(n+1)*n*(n-1)*(i*pi/m+1);\n    //         ans2=ans2+i*pi/m;\n    //     }\n    //     else{\n    //         ans1=ans1+1.0/2.0*(n+1)*n*(n-1);\n    //         ans2=ans2+2.0;\n    //     }\n    // }\n    ans1*=2;\n    ans1=ans1+n*(n+1)*(4*n-1)/6.0;\n    ans=ans+ans1*2*m;\n\n    ans2=ans2*2+2;\n    ans2*=m;\n    ans=ans+ans2*n*(n+1.0)/2.0;\n\n\n    // for(ld r2=1;r2<=n;r2++){\n    //     //圆内:\n    //     ld ans1=0;\n    //     for(ld i=1;i<=m-1;i++){\n    //         if(i*pi*r2/m<2*r2){\n    //             ans1=ans1+r2*(r2-1.0)/2.0*(i*pi/m+1);\n    //         }\n    //         else{\n    //             ans1=ans1+3*r2/2.0*(r2-1);// /2出错\n    //         }\n    //     }  \n    //     ans1=ans1*2;\n    //     ans1=ans1+r2*(2*r2-1);\n    //     ans1=ans1*2*m;\n    //     ans+=ans1;\n    //     //圆上：\n    //     ld ans2=0;\n    //     for(ld i=1;i<=m-1;i++){\n    //         ans2+=min(i*pi*r2/m,(ld)2*r2);\n    //     }\n    //     ans2=ans2*2+2*r2;\n    //     ans=ans+ans2*2*m/2.0;\n    // }\n    printf(\"%.10Lf\\n\",ans);\n}\nint main(){\n    cin>>n>>m;\n    solve();\n    return 0;\n}\n```\n","tags":["思维","数学","好题"]},{"title":"二分思维好题","url":"/2021/10/20/二分思维好题/","content":"\n[Walker Gym - 102900D](https://vjudge.net/problem/Gym-102900D)\n\n题面：在一个长为n的线段，左端点为0，右端点为n\n\n有两个端点分别位于p1,p2，它们的速度分别为v1,v2\n\n问最少需要多少时间，可以使得p1，p2的路程覆盖整条线段\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n·\n··\n\n··\n\n·\n·\n·\n\n思路：\n分类讨论：\n\n先令p1<p2\n\n①p1走完全程\n\n②p2走完全程\n\n③p1向右走完全部，p2向左走完全部\n\n④p1走完左边的全部，p2走完右边的全部，剩余中间的部分p1与p2共同走完，二分中间相遇位置即可。\n\n踩坑:最后二分出来的结果，没有取max(t1,t2)，只取了t1的值wa了。\n原因是二分出来的最后结果，不能保证t1==t2.\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-20 15:21:01\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nld x,x1,v1,x2,v2,ans;\nvoid load(ld xx){\n    ans=min(ans,xx);\n}\nvoid solve(){\n    ld xx=min(x+x1,x-x1+x);\n    load(xx/v1);//A走完全程\n    xx=min(x+x-x2,x+x2);\n    load(xx/v2);//B走完全程\n    ld tt=max((x-x1)/v1,x2/v2);\n    load(tt);//A,B对向走\n    ld l=x1,r=x2;\n    while(r-l>1e-12){\n        ld mid=(l+r)/2;\n        ld t1=min(x1+mid,mid+mid-x1)/v1;\n        ld t2=min(x-mid+x2-mid,x-mid+x-x2)/v2;\n        //load(max(t1,t2));\n        if(t1<t2)  l=mid;\n        else  r=mid;\n    }\n    ld t1=min(x1+l,l+l-x1)/v1;\n    ld t2=min(x-l+x2-l,x-l+x-x2)/v2;\n    load(max(t1,t2));\n    printf(\"%.10LF\\n\",ans);\n}\nint main(){\n    ll ca;cin>>ca;\n    while(ca--){\n        scanf(\"%Lf%Lf%Lf%Lf%Lf\",&x,&x1,&v1,&x2,&v2);\n        if(x1>x2){\n            swap(x1,x2);swap(v1,v2);\n        }\n        ans=1e12;\n        solve();\n    }\n    return 0;\n}\n\n\n```\n","tags":["二分","思维"]},{"title":"最短路的路径","url":"/2021/10/18/最短路的路径/","content":"\n最短路路径存储:存储每个点的前驱路径\n\n<!--more-->\n\n[find the longest of the shortest HDU - 1595 ](https://vjudge.net/problem/HDU-1595)\n\n题意：任删一条边，求删除一条边后最长的那条最短路。有n < 1e3个点,m < 1e6条边。 \n\n题解：枚举删除每条边明显超时，仔细想想，发现删除非最短路上的边，最短路不会变化，所以先整一遍最短路标记最短路上的边，然后枚举删除最短路边即可。\n\n很高兴的是，自己独立做出来了，通过存储每个点的前驱路径，来达到存储最短路径的效果。\n代码优化:  删边可以直接让此边的权值为INF即可。\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-18 17:24:09\n*/\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=1e3+11;\nconst ll maxm=1e6+11;\nstruct Edge{\n    ll fr,to,w,ne;\n}e[maxm];\nll head[maxn],dis[maxn],vis[maxn],pre[maxn];\nll n,m,start,flag,tmp;\npriority_queue<P,vector<P>,greater<P>> q;\nvoid init(){\n    memset(head,0,sizeof(head));tmp=2;\n}\nvoid add(ll u,ll v,ll w){\n    e[tmp]={u,v,w};e[tmp].ne=head[u];head[u]=tmp++;\n}\nvoid dij(){\n    memset(dis,0x1f,sizeof(dis));memset(vis,0,sizeof(vis));\n    q.push({0,start});dis[start]=0;\n    while(!q.empty()){\n        ll u=q.top().second;q.pop();\n        if(vis[u])  continue;\n        vis[u]=1;\n        for(ll i=head[u];i;i=e[i].ne){\n            ll v=e[i].to;\n            if(!vis[v] && dis[u]+e[i].w<dis[v]){\n                dis[v]=dis[u]+e[i].w;\n                if(flag)  pre[v]=i;\n                q.push({dis[v],v});\n            }\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin>>n>>m){\n        init();\n        for(ll i=1;i<=m;i++){\n            ll u,v,w;cin>>u>>v>>w;\n            add(u,v,w);add(v,u,w);\n        }\n        start=1;flag=1;\n        dij();\n        ll ans=dis[n];\n        flag=0;\n        for(ll v=n;v!=1;){\n            ll i=pre[v];\n            ll w=e[i].w;\n            e[i].w=e[i^1].w=INF;//这里直接改就行了\n            dij();\n            ans=max(ans,dis[n]);\n            e[i].w=e[i^1].w=w;\n            v=e[i].fr;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n```","tags":["最短路"]},{"title":"矩阵最短路","url":"/2021/10/18/矩阵最短路/","content":"\n\n[The Shortest Path HDU - 2807 ](https://vjudge.net/problem/HDU-2807)\n\n题面：有n < 80个点，每个点用一个m * m(m < 80)的矩阵表示，若a,b,c三个点满足a * b=c，则表示a到c有一条长度为1的单向边。\n有q < 80次询问，每次询问x,y的最短路\n\n关键在于如何处理这个矩阵。\n\n思路在下面\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n\n这道题挺有意思的，得处理下矩阵的相乘，其实没必要弄得很复杂，直接暴力处理就行了。\n\nfloyd变形题，处理一下矩阵即可，因为数据不大，暴力求就行，也可以采取乘法优化。踩坑：注意A*B=B不能说明AB之间有边，在这里wa了\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-11 11:00:11\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-18 15:18:30\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=1e2+11;\nstruct Node{\n    ll a[maxn][maxn];\n}city[maxn];\nll gra[maxn][maxn];\nll n,m;\nvoid matirx(ll u,ll t){\n    ll mid[maxn][maxn];\n    for(ll i=1;i<=m;i++){\n        for(ll j=1;j<=m;j++){\n            mid[i][j]=0;\n            for(ll k=1;k<=m;k++){\n                mid[i][j]+=city[u].a[i][k]*city[t].a[k][j];\n            }\n        }\n    }\n    for(ll v=1;v<=n;v++){\n        if(v==u || v==t)  continue;\n        ll flag=1;\n        for(ll i=1;i<=m;i++){\n            if(flag==0)  break;\n            for(ll j=1;j<=m;j++){\n                if(mid[i][j]!=city[v].a[i][j]){\n                    flag=0;break;\n                }\n            }\n        }\n        if(flag)  gra[u][v]=1;\n    }\n}\nvoid floyd(){\n    for(ll k=1;k<=n;k++){\n        for(ll i=1;i<=n;i++){\n            for(ll j=1;j<=n;j++)  gra[i][j]=min(gra[i][j],gra[i][k]+gra[k][j]);\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin>>n>>m && (n||m)){\n        memset(gra,0x1f,sizeof(gra));\n        for(ll c=1;c<=n;c++){\n            for(ll i=1;i<=m;i++){\n                for(ll j=1;j<=m;j++)  cin>>city[c].a[i][j];\n            }\n        }\n        for(ll i=1;i<=n;i++){\n            for(ll j=1;j<=n;j++){\n                if(i==j)  continue;\n                matirx(i,j);\n            }\n        }\n        floyd();\n        ll q;cin>>q;\n        for(ll i=1;i<=q;i++){\n            ll u,v;cin>>u>>v;\n            if(gra[u][v]>1e9)  cout<<\"Sorry\"<<endl;\n            else  cout<<gra[u][v]<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构","好题","最短路"]},{"title":"思维题","url":"/2021/10/16/思维题/","content":"\n头脑风暴\n\n<!--more-->\n\n# [Lights and Robot](https://ac.nowcoder.com/acm/contest/20862/B)\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n    推公式题，若没有D操作，答案为(R+C)*N-2*R*C;\n    有D操作，就是:(R+C)*N-2*R*C+(diag?1:0)*(N-2*C-2*R+4*D))\n\n  </code></pre>\n</details>\n\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nbitset<100010> Rmap,Cmap;\nint R,C,D;\nbool diag;\nint N,M;\nint T,E;\n\nvoid initial(){\n\tR=C=D=0;\n\tdiag=false;\n\tRmap.reset();\n\tCmap.reset();\n}\n\nbool blank(const char&x){\n\treturn x==' '||x=='\\n'||x==EOF;\n}\n\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tinitial();\n\t\tfor(int i=0;i<M;i++){\n\t\t\tchar op;\n\t\t\twhile(blank(op=getchar()));\n\t\t\tif(op=='C'){\n\t\t\t\tscanf(\"%d\",&E);\n\t\t\t\tif(Rmap[E]==true&&Cmap[E]==true){\n\t\t\t\t\tD--;\n\t\t\t\t}\n\t\t\t\tif(Cmap[E]==true){\n\t\t\t\t\tC--;\n\t\t\t\t\tCmap[E]=false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tC++;\n\t\t\t\t\tCmap[E]=true;\n\t\t\t\t}\n\t\t\t\tif(Rmap[E]==true&&Cmap[E]==true){\n\t\t\t\t\tD++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op=='D'){\n\t\t\t\tdiag=!diag;\n\t\t\t}\n\t\t\telse if(op=='R'){\n\t\t\t\tscanf(\"%d\",&E);\n\t\t\t\tif(Rmap[E]==true&&Cmap[E]==true){\n\t\t\t\t\tD--;\n\t\t\t\t}\n\t\t\t\tif(Rmap[E]==true){\n\t\t\t\t\tR--;\n\t\t\t\t\tRmap[E]=false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tR++;\n\t\t\t\t\tRmap[E]=true;\n\t\t\t\t}\n\t\t\t\tif(Rmap[E]==true&&Cmap[E]==true){\n\t\t\t\t\tD++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout<<R<<' '<<C<<' '<<D<<' '<<N<<' '<<diag<<endl;\n\t\t\tprintf(\"%lld\\n\",((ll)R+(ll)C)*(ll)N-(ll)2*(ll)R*(ll)C+(diag?(ll)1:(ll)0)*((ll)N-(ll)2*(ll)C-(ll)2*(ll)R+(ll)4*(ll)D));\n\t\t}\n\t}\n}\n```\n\n# [Sequence I](https://ac.nowcoder.com/acm/contest/20862/E)\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n取绝对值，其实就两种情况，要么a-b,要么b-a.那么每次分这两种情况暴力即可。\n\n  </code></pre>\n</details>\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N,MAX,A[10],T;\n\nint ABS(int x){\n\tif(x<0)return -x;\n\treturn x;\n}\n\nvoid dfs(int ans,int d){\n\tif(d==N){\n\t\tif(ABS(ans)<MAX)MAX=ABS(ans);\n\t\treturn;\n\t}\n\tdfs(ans+A[d],d+1);\n\tdfs(ans-A[d],d+1);\n}\n\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d\",&N);\n\t\tMAX=1E8;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&A[i]);\n\t\t}\n\t\tdfs(0,0);\n\t\tprintf(\"%d\\n\",MAX);\n\t}\n}\n```\n\n# [Flight Collision ](https://codeforces.com/gym/103049/problem/F) \n\n题意：一维坐标上飞机具有\\(x_i\\)坐标和速度\\(v_i\\)，其中速度是矢量\n若两飞机相遇则会同时消失，问最后留下的飞机的编号\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n观察到性质每次相撞的飞机总是前一时间相邻的飞机\n每次当前局面下第一次相撞的飞机是相对速度除以距离最大的飞机\n每次删除这对飞机，然后添加 删除这对飞机之后相邻 的飞机。\n\n  </code></pre>\n</details>\n\n```cpp\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef long double lb;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nll v[maxn],x[maxn];\npriority_queue<pair<lb,P>> q;\nset<ll> s;\nvoid add(ll i,ll j){\n    if(v[i]-v[j]<=0)  return ;\n    lb t=((lb)v[i]-(lb)v[j])/((lb)x[j]-(lb)x[i]);\n    q.push({t,{i,j}});\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;cin>>n;\n    for(ll i=1;i<=n;i++){\n        cin>>x[i]>>v[i];\n        s.insert(i);\n    }\n    for(ll i=1;i<n;i++){\n        add(i,i+1);\n    }\n    while(!q.empty() && !s.empty()){\n        P p=q.top().second;\n        ll i=p.first,j=p.second;\n        q.pop();\n        if(!s.count(i) || !s.count(j))  continue;\n        s.erase(i);s.erase(j);\n        if(s.empty())  break;\n        auto it=s.lower_bound(i);\n        if(it==s.begin() || it==s.end())  continue;\n        i=*(--it);\n        it=s.lower_bound(j);\n        j=*it;\n        add(i,j);\n    }\n    cout<<s.size()<<endl;\n    for(auto it=s.begin();it!=s.end();it++)  cout<<*it<<\" \";\n    return 0;\n}\n\n```\n\n# [Stack Sort I](https://ac.nowcoder.com/acm/contest/20862/G)\n\n题意：有三个栈，a,b,c，初始a栈中有n < 1e3个元素，现需要借助b,c两个栈来操作使a栈中的元素按非递减排列。\n操作是指将x栈顶的元素push到y栈顶。输出操作的过程，操作次数小于2e4。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n递归，分治的思想\n若能将一个非有序序列分为两个有序序列，那么这两个序列再归并就能形成一个有序序列。\n故每次将一个序列分为两个序列，最后再将两个有序的序列归并即可。\n\n  </code></pre>\n</details>\n\n```cpp\n\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:41\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-17 21:44:32\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nstack<ll> st[5];\nvector<P> ans;\nvoid opt(ll x,ll y){\n    st[y].push(st[x].top());\n    st[x].pop();\n    ans.push_back({x+1,y+1});\n}\nvoid sort(ll x,ll n,ll d){\n    if(n==1)  return ;\n    ll m=n/2,k=n-m;\n    ll y=(x+1)%3,z=(x+2)%3;\n    for(ll i=1;i<=m;i++)  opt(x,y);\n    for(ll i=1;i<=k;i++)  opt(x,z);\n    sort(y,m,d^1);\n    sort(z,k,d^1);\n    for(ll i=0,j=0;i<m or j<k;){\n        if(i==m)  opt(z,x),j++;\n        else if(j==k)  opt(y,x),i++;\n        else if(d ^ (st[y].top()<st[z].top()))  opt(z,x),j++;\n        else  opt(y,x),i++;\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll N;cin>>N;\n    for(ll i=0,a;i<N;i++)  cin>>a,st[0].push(a);\n    sort(0,N,0);\n    cout<<ans.size()<<endl;\n    for(auto i=ans.begin();i!=ans.end();i++)  cout<<(*i).first<<\" \"<<(*i).second<<endl;\n    return 0;\n}\n\n\n```\n\n\n# [Mine Sweeper II ](https://vjudge.net/problem/Gym-102900B)\n\n题意：有A，B两个扫雷图，图的规格为n行m列，n,m < 1e3,让B最多操作n*m/2次，使得A，B两个数字之和相等。\n操作是指将数字变雷，或雷变数字。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n![](/uploads/思维题/2021-10-19-19-52-34.png)\n\n  </code></pre>\n</details>\n\n\n\n\n\n\n","tags":["思维"]},{"title":"图论综合题","url":"/2021/10/12/图论综合题/","content":"\ngraph n个点 m条边\n\n<!--more-->\n\n# 一般\n[K. Königsberg Bridges](http://codeforces.com/gym/103098/problem/K)\n\n题面：给一个n<1e6个点，m<1e6条边，添加几条边使得图存在一条路径遍历所有的桥，问桥最多能有多少条。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\ne-dcc+树的直径\n注意图的坑点，是要存在一条路径遍历所有的桥，所以对于一棵树，使其桥最多的路，为直径。\n\n  </code></pre>\n</details>\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:29:13\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e6+11;\nstruct Edge{\n    ll fr,to,next;\n}edge[maxn<<1],edgesk[maxn<<1];\nll head[maxn],headsk[maxn],dfn[maxn],low[maxn],c[maxn],vis[maxn],d[maxn],ds[maxn];\nll dcc,tmp,tmpsk,cnt,n,m,num,zj;\nbool bridge[maxn<<1];\nvoid add(ll u,ll v){\n    edge[tmp]={u,v};edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid addsk(ll u,ll v){\n    edgesk[tmpsk]={u,v};edgesk[tmpsk].next=headsk[u];\n    headsk[u]=tmpsk++;\n}\nvoid tarjan(ll x,ll faedge){\n    dfn[x]=low[x]=cnt++;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y,i);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]<low[y]){\n                bridge[i]=bridge[i^1]=true;\n            }\n        }\n        else if(i != (faedge ^ 1)){\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n}\nvoid dfs(ll x){\n    c[x]=dcc;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(c[y] || bridge[i])  continue;\n        dfs(y);\n    }\n}\nvoid dfsf(ll x,ll fa){\n    vis[x]=1;\n    if(d[x]>zj){\n        zj=d[x];num=x;\n    }\n    for(ll i=headsk[x];i;i=edgesk[i].next){\n        ll y=edgesk[i].to;\n        if(y==fa)  continue;\n        d[y]=d[x]+1;\n        dfsf(y,x);\n    }\n}\nvoid dfss(ll x,ll fa){\n    vis[x]=1;\n    if(ds[x]>zj){\n        zj=ds[x];num=x;\n    }\n    for(ll i=headsk[x];i;i=edgesk[i].next){\n        ll y=edgesk[i].to;\n        if(y==fa)  continue;\n        ds[y]=ds[x]+1;\n        dfss(y,x);\n    }\n}\nvoid solve(){\n    ll ans=0;\n    for(ll i=1;i<dcc;i++){\n        if(!vis[i]){\n            ans++;\n            zj=-1;\n            dfsf(i,-1);\n            dfss(num,-1);\n            ans+=zj;\n        }\n    }\n    cout<<ans-1<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    tmp=tmpsk=2;cnt=1;dcc=1;\n    for (ll i = 1; i <= m; i++) {\n        ll x, y;cin>>x>>y;\n        add(x, y), add(y, x);\n    }\n    for (ll i = 0; i < n; i++)\n        if (!dfn[i]) tarjan(i, 0);\n    for(ll i=0;i<n;i++){\n        if(!c[i]){\n            dfs(i);\n            dcc++;\n        }\n    }\n    for(ll i=2;i<tmp;i++){\n        ll u=edge[i].fr,v=edge[i].to;\n        if(c[u]==c[v])  continue;\n        addsk(c[u],c[v]); //无向图\n    }\n    solve();\n    return 0;\n}\n\n```","tags":["图论"]},{"title":"二分","url":"/2021/10/12/二分/","content":"\n据说只有10%的程序员能写对二分😮\n\n<!--more-->\n\n# 二分的正确姿势\n\n先看一个最简单的例子：\n\n升序下，找第一个>=x的数\n```cpp\nl=0,r=v.size();\nwhile(l<r){\n    ll mid=(l+r)>>1;\n    if(v[mid]<x)  l=mid+1;//写二分的诀窍\n    else  r=mid;\n}\n```\n\n大多数情况下,l=0,r=v.size(),那我们接下来都在这种情况下讨论\n\n* 为什么mid是(l+r)>>1，不是(l+r+1)>>1；因为如果是后者,mid可能等于r，导致越界错误.\n* 由于mid每次靠近区间左端，所以对于v[ mid ]  后面接的肯定是l=mid+1，这样子很舒服(具体怎么解释不清楚。。)\n* 那么由前两点，我们只需要改中间的判断条件即可。\n* 注意升序对应>=x和>x，无<=x和 < x。因为升序导致了只能是>号\n\n* 一些模板：\n\n* 升序排序下：\n* 找第一个>=x的数\n```cpp\nl=0,r=v.size();\nwhile(l<r){\n    ll mid=(l+r)>>1;\n    if(v[mid]<x)  l=mid+1;\n    else  r=mid;\n}\n```\n\n* 找第一个>x的数\n```cpp\nl=0,r=v.size();\nwhile(l<r){\n    ll mid=(l+r)>>1;\n    if(v[mid]<=x)  l=mid+1;\n    else  r=mid;\n}\n```\n\n* 降序排序下：\n* 找第一个<=x的数\n```cpp\nl=0,r=v.size();\nwhile(l<r){\n    ll mid=(l+r)>>1;\n    if(v[mid]>x)  l=mid+1;\n    else  r=mid;\n}\n```\n\n* 找第一个< x的数\n```cpp\nl=0,r=v.size();\nwhile(l<r){\n    ll mid=(l+r)>>1;\n    if(v[mid]>=x)  l=mid+1;\n    else  r=mid;\n}\n```\n\n# 4⭐二分好题-扎实的STL\n[Monopoly HDU - 7130 ](https://vjudge.net/problem/HDU-7130)\n题意：由n<1e5个数排列成一个圆，一只猴子从第一个数开始，每走一步则得到该数的值。有m<1e5次询问，问得到x最少需要多少步\n\n题解：\n![](/uploads/二分/2021-10-12-21-10-06.png)\n\n题解说可以用set写，但是估计是每次set插入的时候都要保证有序，比较耗时，导致t了，于是我用了map< ll,vector< P > >，全插入完之后再排个序，就快很多。\n\n踩坑：\n1.re:因为周期t可能很大，开始用的set,set[ x%t ]就re了\n2.wa:负数取模一定要取模后再加上模数,直接取模再abs是错的。\n\n```cpp\n//set<ll> se[maxn];//这里t很大re了。。。。。。。\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=1e5+11;\n\nll sum[maxn],ar[maxn];\nll n,t,m;\n\nmap<ll,vector<P>> mp;\nbool cmp(P a,P b){\n    if(a.first!=b.first)  return a.first<b.first;\n    return a.second>b.second;\n}\nvoid solve(ll x){\n    ll b=abs((x%t+abs(t))%t);\n    ll l=0,r=mp[b].size();\n    while(l<r){\n        ll mid=(l+r)>>1;\n        if(mp[b][mid].first<=x)  l=mid+1;\n        else  r=mid;\n    }\n    if(l==0){\n        cout<<-1<<endl;return ;\n    }\n    l--;\n    ll u=mp[b][l].first,v=mp[b][l].second;\n    cout<<(x-u)/(abs(t))*n+v<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca;cin>>ca;\n    while(ca--){\n        mp.clear();\n        ll q;cin>>n>>q;\n        for(ll i=1;i<=n;i++)  cin>>ar[i];\n        sum[0]=0;\n        for(ll i=1;i<=n;i++)  sum[i]=sum[i-1]+ar[i];\n        t=sum[n];\n        if(t==0){\n            for(ll i=0;i<=n;i++){\n                if(mp.count(sum[i]))  continue;\n                mp[sum[i]].push_back({sum[i],i});\n            }\n            for(ll i=1;i<=q;i++){\n                ll x;cin>>x;\n                if(mp.count(x))  cout<<mp[x][0].second<<endl;\n                else  cout<<-1<<endl;\n            }\n            continue;\n        }\n        if(t<0){\n            for(ll i=0;i<=n;i++)  sum[i]=-sum[i];\n        }\n        for(ll i=0;i<=n;i++){\n            ll x=abs((sum[i]%t+abs(t))%t);//处理为负数的情况！不能直接%t就完事了\n            mp[x].push_back({sum[i],i});\n        }\n        for(auto i=mp.begin();i!=mp.end();i++){\n            sort(i->second.begin(),i->second.end(),cmp);\n        }\n        for(ll i=1;i<=q;i++){\n            ll x;cin>>x;\n            if(t<0)  x=-x;\n            solve(x);\n        }\n    }\n    return 0;\n}\n```","tags":["基本算法"]},{"title":"树的直径","url":"/2021/10/04/树的直径/","content":"\n两次dfs/bfs 树形dp\n\n<!--more-->\n\n# 树的直径\n\n[Roads in the North ](https://vjudge.net/problem/POJ-2631)\n模板\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-10-08 11:23:22\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-08 12:29:44\n*/\n#include<iostream>\n#include<cstring>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,w,next;\n}edge[maxn];\nll head[maxn],d[maxn],tmp=1,num,zj;\nvoid add(ll u,ll v,ll w){\n    edge[tmp]={v,w};edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid dfsf(ll x,ll fa){\n    if(d[x]>zj){\n        zj=d[x];\n        num=x;\n    }\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(y==fa)continue;\n        d[y]=d[x]+edge[i].w;\n        dfsf(y,x);\n    }\n}\nvoid dfss(ll x,ll fa){\n    if(d[x]>zj){\n        zj=d[x];\n        num=x;\n    }\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(y==fa)continue;\n        d[y]=d[x]+edge[i].w;\n        dfss(y,x);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll u,v,w;\n    while(cin>>u>>v>>w){\n        add(u,v,w);add(v,u,w);\n    }\n    zj=0;\n    dfsf(1,0);\n    memset(d,0,sizeof(d));\n    dfss(num,0);\n    cout<<zj<<endl;\n    return 0;\n}\n```\n\n# 灵活运用+思维\n[P5536 【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)\n\n[题解](https://www.luogu.com.cn/problem/solution/P5536)\n* 常规思路-树的直径\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define N 100010\nint n,k,zj,num,ans_k;\nint cut,head[N],ver[2*N],next[2*N];\nint deep[N],f[N],maxdeep[N],ans[N];\nbool cmp(int a,int b){\n    return a>b;\n}\nvoid add(int x,int y){\n    ver[++cut]=y;next[cut]=head[x];head[x]=cut;\n}\n//求直径\nvoid dfs1(int x,int fa){\n    if(deep[x]>zj){\n        zj=deep[x];\n        num=x;\n    }\n    for(int i=head[x];i;i=next[i]){\n        int y=ver[i];\n        if(y==fa)continue;\n        deep[y]=deep[x]+1;\n        dfs1(y,x);\n    }\n}\nvoid dfs2(int x,int fa){\n    if(deep[x]>zj){\n        zj=deep[x];\n        num=x;\n    }\n    for(int i=head[x];i;i=next[i]){\n        int y=ver[i];\n        if(y==fa)continue;\n        deep[y]=deep[x]+1;\n        f[y]=x;\n        dfs2(y,x);\n    }\n}\n//\nvoid dfs_k(int x,int fa){\n    maxdeep[x]=deep[x];\n    for(int i=head[x];i;i=next[i]){\n        int y=ver[i];\n        if(y==fa)continue;\n        deep[y]=deep[x]+1;\n        dfs_k(y,x);\n        maxdeep[x]=max(maxdeep[x],maxdeep[y]);\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        add(x,y);\n        add(y,x);\n    }\n    //直径\n    dfs1(1,0);\n    memset(deep,0,sizeof(deep));\n    zj=0;\n    dfs2(num,0);\n    //\n    int kkk=num;\n    //找直径的中点\n    for(int i=1;i<=(deep[num]+1)/2;++i)kkk=f[kkk];\n    memset(deep,0,sizeof(deep));\n    //再搜一次\n    dfs_k(kkk,0);\n    for(int i=1;i<=n;++i)ans[i]=maxdeep[i]-deep[i];\n    sort(ans+1,ans+n+1,cmp);\n    //QwQ结合图片不难想\n    for(int i=k+1;i<=n;++i)ans_k=max(ans_k,ans[i]+1);\n    printf(\"%d\\n\",ans_k);\n    return 0;\n}\n```\n\n* 逆向思维\n[转载](https://www.luogu.com.cn/blog/zcmimi/solution-p5536)\n我们可以考虑放n-k个节点然后使深度最大的最小\n\n一开始的时候可以反过来想：树里面长度最大的路径就是树的直径，它的两个端点的度都是1（也就是叶子节点）\n\n我们可以从每个叶子结点开始，向中心包围。可以用队列的方式实现。\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 17:51:27\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn];\nll head[maxn],c[maxn],d[maxn],n,k,tmp=1;\nqueue<ll> q;\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>k;\n    for(ll i=1,u,v;i<=n-1;i++){\n        cin>>u>>v;\n        add(u,v);add(v,u);c[u]++;c[v]++;\n    }\n    for(ll i=1;i<=n;i++)  if(c[i]==1)  {\n        q.push(i);d[i]=1;\n    }\n    ll cnt=n-k;\n    while(1){\n        ll x=q.front();q.pop();\n        if(--cnt==0){\n            cout<<d[x]<<endl;\n            return 0;\n        }\n        for(ll i=head[x];i;i=edge[i].next){\n            ll v=edge[i].to;c[v]--;\n            if(c[v]==1){\n                q.push(v);d[v]=d[x]+1;\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["图论"]},{"title":"tarjan","url":"/2021/10/04/tarjan/","content":"\n哦，是tarjan。\n\n<!--more-->\n\n# 题单\n- [ ] [图论综合性很强的一道好题](https://vjudge.net/problem/POJ-2942)\n- [ ] [缩点](https://www.luogu.com.cn/problem/P3387)\n# 无向图\n\n## 割边判定\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:13:27\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn];\nll head[maxn],dfn[maxn],low[maxn],tmp,cnt,n,m;\nbool bridge[maxn];\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid tarjan(ll x,ll faedge){\n    dfn[x]=low[x]=cnt++;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y,i);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]<low[y]){\n                bridge[i]=bridge[i^1]=true;\n            }\n        }\n        else if(i != (faedge ^ 1)){\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    tmp = 2;cnt=1;\n    for (ll i = 1; i <= m; i++) {\n        ll x, y;cin>>x>>y;\n        add(x, y), add(y, x);\n    }\n    for (ll i = 1; i <= n; i++)\n        if (!dfn[i]) tarjan(i, 0);\n    for (ll i = 2; i < tmp; i += 2)\n        if (bridge[i])\n            cout<<edge[i^1].to<<\" \"<<edge[i].to<<endl;\n    return 0;\n}\n```\n\n## 割点判定\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-03 20:31:46\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn];\nll head[maxn],dfn[maxn],low[maxn],tmp,cnt,n,m,root;\nvector<ll> v;\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid tarjan(ll x){\n    dfn[x]=low[x]=cnt++;\n    ll flag=0;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]<=low[y]){\n                flag++;\n                if(x!=root || flag>=2)  v.push_back(x);\n            }  \n        }\n        else  low[x]=min(low[x],dfn[y]);\n    }\n}\nvoid solve(){\n    for(ll i=1;i<=n;i++){\n        if(!dfn[i])  {root=i;tarjan(i);}\n    }\n    sort(v.begin(),v.end());\n    auto en=unique(v.begin(),v.end());\n    cout<<en-v.begin()<<endl;\n    for(auto i=v.begin();i!=en;i++)  cout<<*i<<\" \";\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>m;\n    tmp=1;cnt=1;\n    for(ll i=1,x,y;i<=m;i++){\n        cin>>x>>y;\n        if(x==y)  continue;\n        add(x,y);\n    }\n    solve();\n    return 0;\n}\n```\n## 边双连通分量e-dcc\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:27:08\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn];\nll head[maxn],dfn[maxn],low[maxn],c[maxn],dcc,tmp,cnt,n,m;\nbool bridge[maxn];\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid tarjan(ll x,ll faedge){\n    dfn[x]=low[x]=cnt++;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y,i);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]<low[y]){\n                bridge[i]=bridge[i^1]=true;\n            }\n        }\n        else if(i != (faedge ^ 1)){\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n}\nvoid dfs(ll x){\n    c[x]=dcc;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(c[y] || bridge[i])  continue;\n        dfs(y);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    tmp = 2;cnt=1;dcc=1;\n    for (ll i = 1; i <= m; i++) {\n        ll x, y;cin>>x>>y;\n        add(x, y), add(y, x);\n    }\n    for (ll i = 1; i <= n; i++)\n        if (!dfn[i]) tarjan(i, 0);\n    for (ll i = 2; i < tmp; i += 2)//输出桥\n        if (bridge[i])\n            cout<<edge[i^1].to<<\" \"<<edge[i].to<<endl;\n    for(ll i=1;i<=n;i++){\n        if(!c[i]){\n            dfs(i);\n            dcc++;\n        }\n    }\n    Debug(dcc-1);\n    for(ll i=1;i<=n;i++)  cout<<i<<\"belongs to DCC \"<<c[i]<<endl;\n    return 0;\n}\n```\n\n## 边双连通分量e-dcc缩点\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:29:13\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll fr,to,next;\n}edge[maxn],edgesk[maxn];//shrink\nll head[maxn],headsk[maxn],dfn[maxn],low[maxn],c[maxn],dcc,tmp,tmpsk,cnt,n,m;\nbool bridge[maxn];\nvoid add(ll u,ll v){\n    edge[tmp]={u,v};edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid addsk(ll u,ll v){\n    edgesk[tmpsk]={u,v};edgesk[tmpsk].next=headsk[u];\n    headsk[u]=tmpsk++;\n}\nvoid tarjan(ll x,ll faedge){\n    dfn[x]=low[x]=cnt++;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y,i);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]<low[y]){\n                bridge[i]=bridge[i^1]=true;\n            }\n        }\n        else if(i != (faedge ^ 1)){\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n}\nvoid dfs(ll x){\n    c[x]=dcc;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(c[y] || bridge[i])  continue;\n        dfs(y);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    tmp=tmpsk=2;cnt=1;dcc=1;\n    for (ll i = 1; i <= m; i++) {\n        ll x, y;cin>>x>>y;\n        add(x, y), add(y, x);\n    }\n    for (ll i = 1; i <= n; i++)\n        if (!dfn[i]) tarjan(i, 0);\n    for (ll i = 2; i < tmp; i += 2)//输出桥\n        if (bridge[i])\n            cout<<edge[i^1].to<<\" \"<<edge[i].to<<endl;\n    for(ll i=1;i<=n;i++){\n        if(!c[i]){\n            dfs(i);\n            dcc++;\n        }\n    }\n    Debug(dcc-1);\n    for(ll i=1;i<=n;i++)  cout<<i<<\" belongs to DCC \"<<c[i]<<endl;\n    for(ll i=2;i<tmp;i++){\n        ll u=edge[i].fr,v=edge[i].to;\n        if(c[u]==c[v])  continue;\n        addsk(c[u],c[v]);//无向图\n    }\n    return 0;\n}\n```\n\n## 点双连通分量v-dcc\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:37:07\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn]; \nll head[maxn],dfn[maxn],low[maxn],st[maxn],tmp,cnt,num,n,m,root,top;\nvector<ll> dcc[maxn];\nbool cut[maxn];\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid tarjan(ll x){\n    dfn[x]=low[x]=cnt++;\n    st[top++]=x;\n    if(x==root && head[x]==0){\n        dcc[num++].push_back(x);return ;\n    }\n    ll flag=0;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]<=low[y]){\n                flag++;\n                if(x!=root || flag>=2)  cut[x]=true;\n                ll z;\n                do{\n                    z=st[--top];\n                    dcc[num].push_back(z);\n                }while(z!=y);\n                dcc[num++].push_back(x);\n            }  \n        }\n        else  low[x]=min(low[x],dfn[y]);\n    }\n}\nvoid solve(){\n    for(ll i=1;i<=n;i++){\n        if(!dfn[i])  {root=i;tarjan(i);}\n    }\n    for(ll i=1;i<num;i++){\n        for(auto j=dcc[i].begin();j!=dcc[i].end();j++)  cout<<*j<<\" \";\n        cout<<endl;\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>m;\n    tmp=1;cnt=1;num=1;top=1;\n    for(ll i=1,x,y;i<=m;i++){\n        cin>>x>>y;\n        if(x==y)  continue;\n        add(x,y);add(y,x);\n    }\n    solve();\n    return 0;\n}\n```\n\n## 点双连通分量v-dcc缩点\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:48:07\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn],edgesk[maxn]; \nll head[maxn],headsk[maxn],dfn[maxn],low[maxn],st[maxn],c[maxn],n_id[maxn];\nll tmp,tmpsk,cnt,num,n,m,root,top;\nvector<ll> dcc[maxn];\nbool cut[maxn];\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid addsk(ll u,ll v){\n    edgesk[tmpsk].to=v;edgesk[tmpsk].next=headsk[u];\n    headsk[u]=tmpsk++;\n}\nvoid tarjan(ll x){\n    dfn[x]=low[x]=cnt++;\n    st[top++]=x;\n    if(x==root && head[x]==0){\n        dcc[num++].push_back(x);return ;\n    }\n    ll flag=0;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n            if(dfn[x]<=low[y]){\n                flag++;\n                if(x!=root || flag>=2)  cut[x]=true;\n                ll z;\n                do{\n                    z=st[--top];\n                    dcc[num].push_back(z);\n                }while(z!=y);\n                dcc[num++].push_back(x);\n            }  \n        }\n        else  low[x]=min(low[x],dfn[y]);\n    }\n}\nvoid solve(){\n    for(ll i=1;i<=n;i++){\n        if(!dfn[i])  {root=i;tarjan(i);}\n    }\n    for(ll i=1;i<num;i++){\n        for(auto j=dcc[i].begin();j!=dcc[i].end();j++)  cout<<*j<<\" \";\n        cout<<endl;\n    }\n    cnt=num;\n    for(ll i=1;i<=n;i++)  if(cut[i]) n_id[i]=cnt++;\n    tmpsk=1;\n    for(ll i=1;i<num;i++){\n        for(auto j=dcc[i].begin();j!=dcc[i].end();j++){\n            ll x=*j;\n            if(cut[x]){\n                addsk(i,n_id[x]);addsk(n_id[x],i);\n            }\n            else c[x]=i;\n        }\n    }\n    Debug(cnt);Debug(tmpsk/2);\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>m;\n    tmp=1;cnt=1;num=1;top=1;\n    for(ll i=1,x,y;i<=m;i++){\n        cin>>x>>y;\n        if(x==y)  continue;\n        add(x,y);add(y,x);\n    }\n    solve();\n    return 0;\n}\n```\n\n## 求环(每条边至多被一个环包围)\n\n这个求环可以用点双连通分量写\n也可以先跑个树出来，同时**标记每个点的深度,注意不是dfs序！！！**，（考虑一个环外延伸出一个点的情况）,然后再加上非树的边构成环，环的边数就是两点深度之差+1。\n\n[Forest Program](https://codeforces.com/gym/102361/problem/F)\n\n[题解](https://blog.csdn.net/jk_chen_acmer/article/details/101630989)\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-07 21:39:12\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e6+11;\nconst ll mod=998244353;\nstruct Edge{\n    ll fr,to,next;\n}edge[maxn];\nll head[maxn],dfn[maxn],vis[maxn],qp2[maxn],tmp=2,cnt=1,m;\nvoid add(ll u,ll v){\n    edge[tmp]={u,v};edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid dfs(ll u){\n    for(ll i=head[u];i;i=edge[i].next){\n        ll v=edge[i].to;\n        if(!dfn[v]){\n            dfn[v]=dfn[u]+1;\n            vis[i]=vis[i^1]=1;dfs(v);\n        }\n    }\n}\nvoid solve(){\n    ll l=0,ans=1;\n    for(ll i=2;i<tmp;i+=2){\n        if(!vis[i]){\n            ll u=edge[i].fr,v=edge[i].to;\n            ll t=abs(dfn[u]-dfn[v])+1;\n            l+=t;\n            ans=ans*(qp2[t]-1)%mod;\n        }\n    }\n    ans=ans*qp2[tmp/2-1-l]%mod;\n    cout<<ans<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    qp2[0]=1;\n    for(ll i=1;i<maxn;i++)  qp2[i]=qp2[i-1]*2%mod;\n    ll n;cin>>n>>m; \n    for(ll i=1;i<=m;i++){\n        ll u,v;cin>>u>>v;\n        add(u,v);add(v,u);\n    }\n    for(ll i=1;i<=n;i++){\n        if(!dfn[i])  dfn[i]=1,dfs(i);\n    }\n    solve();\n    return 0;\n}\n\n```\n\n## 缩点树度数\n[Road Construction](https://vjudge.net/problem/POJ-3352)\n\n题意：求缩点树中度数为1的个数\n\n这个有几种写法：\n\n1.\n```cpp\nfor(ll i=1;i<=n;i++){\n    for(ll j=head[i];j;j=edge[j].next){\n        if(low[i]!=low[edge[j].to]){\n            re[low[i]]++;\n        }\n    }\n}\n```\n\n这种写法，只能用来求度数为1的点个数，度数为其他不能求，**因为同一个边连通分量的low值不一定一样**。\n\n2.\n```cpp\nfor(ll i=2;i<tmp;i++){\n    if(bridge[i]){\n        ll v=edge[i].to;\n        re[c[v]]++;\n    }\n}\n```\n\n这种写法，就是把它的缩点的块标号，来求每个缩点的度数，是最稳的。\n\n一个错误写法：\n\n3.\n```cpp\nfor(ll i=2;i<tmp;i++){\n    if(bridge[i]){\n        ll v=edge[i].to;\n        re[low[v]]++;\n    }\n}\n```\n\n因为同一个边连通分量的low值不一定是一样的\n\n## 缩点所连接的连通块个数\n\n[ Electricity(POJ2117)](https://vjudge.net/problem/POJ-2117)\n\n题意：一张图，不一定连通。问，删去一个点，最多可以有多少个连通块。\n\n题解：找割点，答案是一开始连通分量个数+割点可产生的最多连通分量的个数。\n\n注意m==0的情况，因为必须要删除一个点，所以输出n-1。\n\n**核心代码：if(u!=root || flag>=2)  cut[u]++;**\n\n最终缩点u所连接的连通块个数为cut[u]+1。因为最开始dfs到u的那条边，没有被统计到\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:37\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-15 15:29:14\n*/\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e4+11;\nconst ll maxm=1e6+11;\nll to[maxm],nex[maxm],head[maxn],dfn[maxn],low[maxn],cut[maxn];\nll tmp,cnt,root,n,m;\nvoid init(){\n    memset(head,0,sizeof(head));memset(dfn,0,sizeof(dfn));\n    memset(cut,0,sizeof(cut));\n    tmp=2,cnt=1;\n}\nvoid add(ll u,ll v){\n    to[tmp]=v;nex[tmp]=head[u];head[u]=tmp++;\n}\nvoid tarjan(ll u){\n    dfn[u]=low[u]=cnt++;\n    ll flag=0;\n    for(ll i=head[u];i;i=nex[i]){\n        ll v=to[i];\n        if(!dfn[v]){\n            tarjan(v);\n            low[u]=min(low[u],low[v]);\n            if(dfn[u]<=low[v]){\n                flag++;\n                if(u!=root || flag>=2)  cut[u]++;\n            }\n        }\n        else  low[u]=min(low[u],dfn[v]);\n    }\n}\nvoid solve(){\n    ll ansf=0,anss=0;\n    for(ll i=0;i<n;i++){\n        if(!dfn[i]){\n            ansf++;root=i;tarjan(i);\n        }\n    }\n    for(ll i=0;i<n;i++)  anss=max(anss,cut[i]);\n    if(anss==0){\n        if(m==0){\n            cout<<ansf-1<<endl;return ;\n        }\n        else{\n            cout<<ansf<<endl;return ;\n        }\n    }\n    cout<<ansf+anss<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin>>n>>m && (n||m)){\n        //Debug(n);Debug(m);\n        init();\n        for(ll i=1;i<=m;i++){\n            ll u,v;cin>>u>>v;\n            add(u,v);add(v,u);\n        }\n        solve();\n    }\n    return 0;\n}\n\n```\n\n# 有向图\n\n## 强连通分量\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:02:53\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn];\nll head[maxn],dfn[maxn],low[maxn],c[maxn],st[maxn],ins[maxn];\nll tmp,top,cnt,num,n,m;\nvector<ll> scc[maxn];\nbool bridge[maxn];\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid tarjan(ll x){\n    dfn[x]=low[x]=cnt++;\n    st[top++]=x;ins[x]=1;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n        }\n        else if(ins[x]){\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n    if(dfn[x]==low[x]){\n        num++;ll y;\n        do{\n            y=st[--top],ins[y]=0;\n            c[y]=num;scc[num].push_back(y);\n        }while(x!=y);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    tmp = 2;cnt=1;num=0;top=1;\n    for (int i = 1; i <= m; i++) {\n        int x, y;cin>>x>>y;\n        add(x, y);\n    }\n    for(int i=1;i<=n;i++){\n        if(!dfn[i])  tarjan(i);\n    }\n    for(ll i=1;i<=num;i++){\n        for(auto j=scc[i].begin();j!=scc[i].end();j++)  cout<<*j<<\" \";\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n## 强连通分量缩点\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-04 14:54:56\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll to,next;\n}edge[maxn],edgesk[maxn];\nll head[maxn],headsk[maxn],dfn[maxn],low[maxn],c[maxn],st[maxn],ins[maxn];\nll tmp,tmpsk,top,cnt,num,n,m;\nvector<ll> scc[maxn];\nbool bridge[maxn];\nvoid add(ll u,ll v){\n    edge[tmp].to=v;edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid addsk(ll u,ll v){\n    edgesk[tmpsk].to=v;edgesk[tmpsk].next=headsk[u];\n    headsk[u]=tmpsk++;\n}\nvoid tarjan(ll x){\n    dfn[x]=low[x]=cnt++;\n    st[top++]=x;ins[x]=1;\n    for(ll i=head[x];i;i=edge[i].next){\n        ll y=edge[i].to;\n        if(!dfn[y]){\n            tarjan(y);\n            low[x]=min(low[x],low[y]);\n        }\n        else if(ins[x]){\n            low[x]=min(low[x],dfn[y]);\n        }\n    }\n    if(dfn[x]==low[x]){\n        num++;ll y;\n        do{\n            y=st[--top],ins[y]=0;\n            c[y]=num;scc[num].push_back(y);\n        }while(x!=y);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    tmp = 2;cnt=1;num=0;top=1;\n    for (int i = 1; i <= m; i++) {\n        int x, y;cin>>x>>y;\n        add(x, y);\n    }\n    for(int i=1;i<=n;i++){\n        if(!dfn[i])  tarjan(i);\n    }\n    for(ll i=1;i<=num;i++){\n        for(auto j=scc[i].begin();j!=scc[i].end();j++)  cout<<*j<<\" \";\n        cout<<endl;\n    }\n    tmpsk=1;\n    for(ll x=1;x<=n;x++){\n        for(ll i=head[x];i;i=edge[i].next){\n            ll y=edge[i].to;\n            if(c[x]==c[y])  continue;\n            addsk(c[x],c[y]);\n        }\n    }\n    return 0;\n}\n```\n\n## 强连通分量缩点基础题\n\n[Summer Holiday HDU - 1827](https://vjudge.net/problem/HDU-1827)\n\n```cpp\n//1827!!!!!!!!!!!!!!!!\n//检查下最小花费\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:37\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-14 14:18:22\n*/\n#include<iostream>\n#include<cstring>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e3+11;\nll fr[maxn],to[maxn],nex[maxn],head[maxn];\nll st[maxn],in[maxn],dfn[maxn],low[maxn],c[maxn],dr[maxn],val[maxn],w[maxn];\nll tmp,cnt,top,num,n,m;\nvoid add(ll u,ll v){\n    fr[tmp]=u;to[tmp]=v;nex[tmp]=head[u];head[u]=tmp++;\n}\nvoid tarjan(ll u){\n    dfn[u]=low[u]=cnt++;in[u]=1;st[top++]=u;\n    for(ll i=head[u];i;i=nex[i]){\n        ll v=to[i];\n        if(!dfn[v]){\n            tarjan(v);\n            low[u]=min(low[u],low[v]);\n        }\n        else if(in[v])  low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u]){\n        num++;ll v;\n        do{\n            v=st[--top];in[v]=0;\n            c[v]=num;w[num]=min(w[num],val[v]);\n        }while(u!=v);\n    }\n}\nvoid solve(){\n    for(ll i=1;i<=n;i++){\n        if(!dfn[i])  tarjan(i);\n    }\n    for(ll i=1;i<tmp;i++){\n        ll u=fr[i],v=to[i];\n        if(c[u]==c[v])  continue;\n        dr[c[v]]++;\n    }\n    ll ans1=0,ans2=0;\n    for(ll i=1;i<=num;i++){\n        if(dr[i]==0){\n            ans1++;\n            ans2+=w[i];\n        }\n    }\n    cout<<ans1<<\" \"<<ans2<<endl;\n}\nvoid init(){\n    memset(head,0,sizeof(head));memset(dfn,0,sizeof(dfn));\n    memset(c,0,sizeof(c));memset(dr,0,sizeof(dr));\n    memset(w,0x3f,sizeof(w));\n    tmp=cnt=1;num=0;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin>>n>>m){\n        init();\n        for(ll i=1;i<=n;i++)  cin>>val[i];\n        for(ll i=1;i<=m;i++){\n            ll u,v;cin>>u>>v;add(u,v);\n        }\n        solve();\n    }\n    return 0;\n}\n\n```\n\n## 建强连通图-巧写dfs序\n\n这道题与求环那道题有点类似，都需要用到dfs序,不过这道题代码写法还是挺巧妙的。\n\n[Street Directions(POJ1515)](https://vjudge.net/problem/POJ-1515)\n\n题意：一个无向连通图，最多能把多少条边改为有向边，使得剩下的图仍然是一个强连通分量。输出剩下的边。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n剩下的无向边必是割边，剩下那些边，会在某个边连通分量，每个边连通分量里的边都可以是有向边，仍然能互相到达，所以tarjan找到所有割边，dfs的顺序就作为有向边的方向即可。\n\n  </code></pre>\n</details>\n\n* 普通dfs序\n\n这个是以dfs序号作为判断，树上的边是dfs序小向dfs序大建边，非树上的边是dfs序大向dfs序小建边\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:37\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-15 11:51:50\n*/\n#include<iostream>\n#include<cstring>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e3+11;\nconst ll maxm=2e6+11;\nll to[maxm],nex[maxm],head[maxn],dfn[maxn],low[maxn],d[maxn];\nll n,m,cnt,num,tmp;\nbool bridge[maxm],t[maxm];\nvoid add(ll u,ll v){\n    to[tmp]=v;nex[tmp]=head[u];head[u]=tmp++;\n}\nvoid tarjan(ll u,ll fue){\n    dfn[u]=low[u]=cnt++;\n    for(ll i=head[u];i;i=nex[i]){\n        ll v=to[i];\n        if(!dfn[v]){\n            tarjan(v,i);\n            low[u]=min(low[u],low[v]);\n            if(dfn[u]<low[v])  bridge[i]=bridge[i^1]=true;\n        }\n        else if(i!=(fue^1))  low[u]=min(low[u],dfn[v]);\n    }\n}\nvoid dfs(ll u){\n    d[u]=num++;\n    for(ll i=head[u];i;i=nex[i]){\n        ll v=to[i];\n        if(!d[v]){\n            t[i]=t[i^1]=true;\n            dfs(v);\n        }\n    }\n}\nvoid solve(){\n    tarjan(1,0);\n    dfs(1);\n    for(ll i=2;i<tmp;i+=2){\n        ll u=to[i],v=to[i^1];\n        if(t[i]){\n            if(d[u]<d[v])  cout<<u<<\" \"<<v<<endl;\n            else  cout<<v<<\" \"<<u<<endl;\n            if(bridge[i]){\n                if(d[u]<d[v])  cout<<v<<\" \"<<u<<endl;\n                else  cout<<u<<\" \"<<v<<endl;\n            }\n        }\n        else{\n            if(d[u]<d[v])  cout<<v<<\" \"<<u<<endl;\n            else  cout<<u<<\" \"<<v<<endl;\n        }\n    }\n}\nvoid init(){\n    memset(head,0,sizeof(head));memset(dfn,0,sizeof(dfn));\n    memset(d,0,sizeof(d));memset(bridge,0,sizeof(bridge));\n    memset(t,0,sizeof(t));\n    cnt=num=1;tmp=2;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca=1;\n    while(cin>>n>>m && (n||m)){\n        cout<<ca++<<endl<<endl;\n        init();\n        for(ll i=1;i<=m;i++){\n            ll u,v;cin>>u>>v;add(u,v);add(v,u);\n        }\n        solve();\n        cout<<'#'<<endl;\n    }\n    return 0;\n}\n```\n\n* 巧写dfs序\n\n由于tarjan本身就是一个dfs的过程，所以没有必要再写一遍dfs。\n所以直接在tarjan过程中标记边即可。\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:37\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-15 11:51:50\n*/\n#include<iostream>\n#include<cstring>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e3+11;\nconst ll maxm=2e6+11;\nint to[maxm],nex[maxm],head[maxn],dfn[maxn],low[maxn],bridge[maxm];\nll n,m,cnt,tmp;\nvoid add(ll u,ll v){\n    to[tmp]=v;nex[tmp]=head[u];head[u]=tmp++;\n}\nvoid tarjan(ll u,ll fue){\n    dfn[u]=low[u]=cnt++;\n    for(ll i=head[u];i;i=nex[i]){\n        ll v=to[i];\n        if(bridge[i]==0){\n            bridge[i]=1;//当前边可用\n            bridge[i^1]=-1;//反向边不可用\n        }\n        if(!dfn[v]){\n            tarjan(v,i);\n            low[u]=min(low[u],low[v]);\n            if(dfn[u]<low[v])  bridge[i]=bridge[i^1]=1;\n        }\n        else if(i!=(fue^1))  low[u]=min(low[u],dfn[v]);\n    }\n}\nvoid solve(){\n    tarjan(1,0);\n    for(ll i=2;i<tmp;i++)  if(bridge[i]==1)  cout<<to[i^1]<<\" \"<<to[i]<<endl;\n}\nvoid init(){\n    memset(head,0,sizeof(head));memset(dfn,0,sizeof(dfn));\n    memset(bridge,0,sizeof(bridge));\n    cnt=1;tmp=2;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca=1;\n    while(cin>>n>>m && (n||m)){\n        cout<<ca++<<endl<<endl;\n        init();\n        for(ll i=1;i<=m;i++){\n            ll u,v;cin>>u>>v;add(u,v);add(v,u);\n        }\n        solve();\n        cout<<'#'<<endl;\n    }\n    return 0;\n}\n\n```","tags":["图论"]},{"title":"acmer-oier编辑神器","url":"/2021/10/01/acmer-oier编辑神器/","content":"\nWow!  算法竞赛，acmer/oier的编辑器之神\n最强IDE CpEditor\n\n<!--more-->\n\n一个专门为算法竞赛，acmer/oier设计的IDE。\nConvenience of convenience!\n\n不多说，直接上图，懂得都懂\n\n![](https://raw.githubusercontent.com/cpeditor/cpeditor/master/assets/demo.gif)\n\nPS: 在新标签页中查看图片更清晰","tags":["工具"]},{"title":"vscode","url":"/2021/09/27/vscode/","content":"\n微软大法好 \n架不住微软人多好赚钱呐\n\n<!--more-->\n\n# Markdown\n\n## Markdown粘贴图片\n\n主要用到paste image这个插件\n\n主要说下我的配置\n\nPaste Image: Base Path 为 D:\\BohongLi\\100-LoveLearning\\150-Blog\\Marhoosh\\source\n\nPaste Image: Path  为  D:\\BohongLi\\100-LoveLearning\\150-Blog\\Marhoosh\\source\\uploads\\${currentFileNameWithoutExt}\n\nPaste Image: Prefix 为  /\n\n博客我用的hexo，效果就是图片保存在hexo的source/uploads/文章名/图片.png  \n这样子每个文章都会有一个对应的图片的文件夹来保存，不会一堆图片杂在一次（强迫症患者）\n而且推送到远端时，(我是推送到github)，图片依然能够看到。","tags":["工具"]},{"title":"一错再错","url":"/2021/09/26/一错再错/","content":"错错错 是我的错\nAC的时候怎么不说\n<!--more-->\n\n# 莫名其妙RE：\n\n## 变量未初始化\n```cpp\nll t;\nfor(ll i=a;i<b;i++)  t=i;\np=t;\nar[p]=1;\n```\np有可能是个未知量，因为t若未进入循环，则其为一个野变量，所以变量得初始化的重要性不言而喻。\n\n\n# TLE\n\n1.求n<1e9的质因子个数\n\n数据量大的时候：\n本来是遍历到1e5超时了，改成遍历到4e4就没超时,900ms\n\n又改了一下，把4e4内的质数都找出来遍历，200ms\n\n所以这种优化，减小了几倍的复杂度，在数据量大的时候，还是十分有用的。数据量小的时候，就不明显了。\n\n# WA哇哇哇\n\n1.仙人掌图求环\n对点标记的树的深度，不是dfs序。\n","tags":["没想好标签的标签"]},{"title":"最小生成树","url":"/2021/09/20/最小生成树/","content":"\nkruskal prim ..\n\n<!--more-->\n\n# kruskal\n* **思路**  贪心，每次选择权值最小的边，保证每次加入新边不会生成环\n* **难点**  如何判定生成环，方法：保证新加入的边的两个端点，不都在已加入的边的端点集合中，用**并查集**实现\n* 链式前向星模板 时间O(m*logm)(m为边数)\n\n```cpp\n//链式前向星(kruskal用邻接矩阵不太好写)-----------------------------------\n/*** \n * @Practice Win\n * 洛谷 P3366 【模板】最小生成树\n * 最小生成树 板子题\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e4+11;//最多点数！！！\nconst ll maxm=1e6+11;//最多边数！！！\nstruct Edge{\n\tll fr,to,w,next;\n}edge[maxm];//边集，下标从1开始！！！\nll fa[maxn],head[maxn];\nll n,m,tmp;\nvoid add(ll u,ll v,ll w){\n\tedge[tmp].fr=u; edge[tmp].to=v; edge[tmp].w=w;\n\tedge[tmp].next=head[u];\n\thead[u]=tmp++;\n}\nbool cmp(Edge a,Edge b){\n\treturn a.w<b.w;\n}\nll found(ll x){\n\treturn fa[x]==x?x:fa[x]=found(fa[x]);\n}\nll kruskal(){//若存在最小生成树，返回其最小权值和,并输出，若不存在，返回一个错误值，并输出“orz”\n\tsort(edge+1,edge+tmp,cmp);\n\tll cnt=0,ans=0;\n\tfor(ll i=1;i<tmp;i++){//边编号从1开始！！！\n\t\tll fu=found(edge[i].fr);//并查集得到fu和fv\n\t\tll fv=found(edge[i].to);\n\t\tif(fu==fv) continue;//若在同一集合，则跳过，说明这两个点都已被使用过\n\t\tfa[fu]=fv;//合并\n\t\tcnt++;\n\t\tans+=edge[i].w;\n\t\tif(cnt==n-1)  break;\n\t}\n\tif(cnt==n-1)  cout<<ans<<endl;\n\telse  cout<<\"orz\"<<endl;\n\treturn ans;\n}\nvoid makset(){\n\tfor(ll i=1;i<=n;i++)  fa[i]=i;//点的编号应与题目相符合！！！\n}\nvoid init(){\n\tmemset(head,-1,sizeof(head));\n\ttmp=1;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m;\n    init();\n    makset();\n    for(ll i=1;i<=m;i++){\n        ll u,v,w;\n        cin>>u>>v>>w;\n        add(u,v,w);//有向图\n\t\t//add(v,u,w);//无向图\n    }\n    kruskal();\n    return 0;\n}\n```\n# 灵活运用，唯一最小生成树（思维）\n**题目链接**  https://vjudge.net/problem/POJ-1679\n**题意**  判断最小生成树是否唯一\n**思路**枚举最小生成树的n条边，每次减去一条边，看最小生成树是否存在 \n\n# 弱思维\n[Cartesian MST](http://codeforces.com/gym/103098/problem/C)\n\n题面：求两个树的笛卡尔积产生的树的最小生成树。\n\n如图：\n\n![](/uploads/最小生成树/2021-10-13-14-32-49.png)\n\n思路：这个画个图，模拟一下应该不难想\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:41\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-13 14:25:30\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll fr,to,w,type;\n    bool operator < (const Edge& b) const {\n        return w<b.w;\n    }\n}e[maxn];\nll f1[maxn],f2[maxn];\nll n1,m1,n2,m2;\nll found1(ll x){\n    return f1[x]==x?x:f1[x]=found1(f1[x]);\n}\nll found2(ll x){\n    return f2[x]==x?x:f2[x]=found2(f2[x]);\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n1>>m1>>n2>>m2;\n    for(ll i=0;i<n1;i++)  f1[i]=i;\n    for(ll i=0;i<n2;i++)  f2[i]=i;\n    ll tmp=0;\n    for(ll i=1;i<=m1;i++){\n        ll u,v,w;cin>>u>>v>>w;\n        e[tmp++]={u,v,w,1};\n    }\n    for(ll i=1;i<=m2;i++){\n        ll u,v,w;cin>>u>>v>>w;\n        e[tmp++]={u,v,w,2};\n    }\n    sort(e,e+tmp);\n    ll cnt=0,cnt1=0,cnt2=0,p=0,ans=0;\n    while(cnt<=n1+n2-2 && p<tmp){\n        ll ty=e[p].type;\n        if(ty==1){\n            if(cnt1>=n1-1){\n                p++;continue;\n            }\n            ll u=e[p].fr,v=e[p].to;\n            ll fu=found1(u),fv=found1(v);\n            if(fu==fv){\n                p++;continue;\n            }  \n            f1[fu]=fv;\n            ans=ans+(n2-cnt2)*e[p].w;\n            cnt1++;cnt++;p++;\n        }\n        else{\n            if(cnt2>=n2-1){\n                p++;continue;\n            }\n            ll u=e[p].fr,v=e[p].to;\n            ll fu=found2(u),fv=found2(v);\n            if(fu==fv){\n                p++;continue;\n            } \n            f2[fu]=fv;\n            ans=ans+(n1-cnt1)*e[p].w;\n            cnt2++;cnt++;p++;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n# prim\n* **思路**  感觉本质上就是kruskal，与kruskal思路没啥区别，要说区别就是kruskal过程上是加边，这个是过程上加点吧，但其实都是每次选择权值最小的边，都是贪心。\n* **具体方法**  弄两个点集，一个u，一个v，每次选择一个端点在u，一个端点在v产生的边中，权值最小的边，并把在v中的点，加入u中。\n* 链式前向星模板 时间O(n*n)\n\n```cpp\n//链式前向星-----------------------------------------------------------------------------\n/*** \n * @Practice Win\n * 畅通工程 HDU - 1863 \n * prim\n * 最小生成树 板子题\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e2+11;//最大顶点数\nstruct Edge{\n\tll fr,to,w,next;\n}edge[maxn*maxn];\nll head[maxn],vis[maxn],dis[maxn];\nll n,m,tmp;\nll prim(){//若存在最小生成树，返回其值并输出，否则返回一个未知值，并输出\"?\"\n\tll minn=INF,pos,ans=0;\n\tfor(ll i=head[1];~i;i=edge[i].next){//从顶点编号1开始初始化\n\t\tll v=edge[i].to;\n\t\tdis[v]=min(dis[v],edge[i].w);//考虑有重边情况！！！\n\t}\n\tvis[1]=1;\n\tfor(ll i=2;i<=n;i++){ \n\t\tll minn=INF;\n\t\tpos=-1;\n\t\tfor(ll j=1;j<=n;j++)  if(!vis[j] && dis[j]<minn)  minn=dis[j],pos=j;\n\t\tif(pos==-1)  break;\n\t\tvis[pos]=1;\n\t\tans+=minn;\n\t\tfor(ll i=head[pos];~i;i=edge[i].next){\n\t\t\tll v=edge[i].to;\n\t\t\tif(edge[i].w<dis[v])  dis[v]=edge[i].w;\n\t\t}\n\t}\n\tif(pos==-1)  cout<<\"?\"<<endl;\n\telse  cout<<ans<<endl;\n\treturn ans;\n}\nvoid add(ll u,ll v,ll w){\n\tedge[tmp].fr=u; edge[tmp].to=v; edge[tmp].w=w;\n\tedge[tmp].next=head[u];\n\thead[u]=tmp++;\n}\t\nvoid init(){\n\tmemset(vis,0,sizeof(vis));\n\tmemset(head,-1,sizeof(head));\n\tmemset(dis,0x3f3f3f3f,sizeof(dis));\n\ttmp=1;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\twhile(cin>>m>>n && m){\n\t\tinit();\n\t\tfor(ll i=1;i<=m;i++){\n\t\t\tll u,v,w;\n\t\t\tcin>>u>>v>>w;\n\t\t\tadd(u,v,w);\n\t\t\tadd(v,u,w);\n\t\t}\n\t\tprim();\n\t}\n    return 0;\n}\n```\n* 邻接矩阵模板 时间O(n*n)\n\n```cpp\n//邻接矩阵-----------------------------------------------------------------------------\n/*** \n * @Practice Win\n * 畅通工程 HDU - 1863 \n * prim\n * 最小生成树 板子题\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e2+11;//最大顶点数\nll vis[maxn],dis[maxn],gra[maxn][maxn];\nll n,m;\nll prim(){//若存在最小生成树，返回其值并输出，否则返回一个未知值，并输出\"?\"\n\tll minn=INF,pos,ans=0;\n\tfor(ll i=1;i<=n;i++)  dis[i]=gra[1][i];\n\tvis[1]=1;\n\tfor(ll i=2;i<=n;i++){ \n\t\tll minn=INF;\n\t\tpos=-1;\n\t\tfor(ll j=1;j<=n;j++)  if(!vis[j] && dis[j]<minn)  minn=dis[j],pos=j;\n\t\tif(pos==-1)  break;\n\t\tvis[pos]=1;\n\t\tans+=minn;\n\t\tfor(ll j=1;j<=n;j++)  if(!vis[j] && gra[pos][j]<dis[j])  dis[j]=gra[pos][j];\n\t}\n\tif(pos==-1)  cout<<\"?\"<<endl;\n\telse  cout<<ans<<endl;\n\treturn ans;\n}\n\t\nvoid init(){\n\tmemset(vis,0,sizeof(vis));\n\tmemset(dis,0x3f3f3f3f,sizeof(dis));\n\tmemset(gra,0x3f3f3f3f,sizeof(gra));\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\twhile(cin>>m>>n && m){\n\t\tinit();\n\t\tfor(ll i=1;i<=m;i++){\n\t\t\tll u,v,w;\n\t\t\tcin>>u>>v>>w;\n\t\t\tif(w<gra[u][v])  gra[u][v]=gra[v][u]=w;\n\t\t}\n\t\tprim();\n\t}\n    return 0;\n}\n```\n# 灵活运用（已建立某些边）\n[继续畅通工程](https://vjudge.net/problem/HDU-1879)\n**题意** 在有些边已经建立好了的情况下，求最小生成树。\n**思路**  对于已经建立的边，将其权值变为0即可。\n# 灵活运用（已知每个点的代价）\n[Shichikuji and Power Grid](https://codeforces.com/problemset/problem/1245/D)\n常见最小生成树是知道每条边的代价，这题增加了一个就是还知道每个点的代价。\n**题面**\n有n个城市,坐标为(xi,yi),还有两个系数ci,ki.在每个城市建立发电站需要费用ci.如果不建立发电站，要让城市通电，就需要与有发电站的城市连通。i与j之间连一条无向的边的费用是(ki+kj)*两个城市之间的曼哈顿距离.求让每个城市都通电的最小费用,并输出任意一个方案。\n\n**分析**\n我刚开始想的就是，这不就是prim，然后将dis[i]初始化为每个点的代价嘛，然后发现这是个常见套路，也可以**把选每个点的代价转成虚拟原点到这个点的边**,不过这样子更好理解。这个套路很常见，但在最小生成树题里还是第一次见到。\n\n城市之间两两连边，边权按题目里提到的计算。然后建立一个虚拟源点，向每个城市i连边，边权为ci.对整个图跑一个最小生成树即可.\n\n------------------------------------------------------------------\n* **总结**\n\n* **两者区别**这个方法的好处就是，因为分成了两个点集合，所以保证了选择的权值最小的边肯定不会产生环，因为这个边的端点分别在两个互斥的集合嘛，不像kruskal选择的边可能都在集合u。 \n* **稀疏图与稠密图**数据结构中对于稀疏图的定义为：有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图（dense graph）。此定义来自百度百科，实际上是一种朴素的理解，简单来说边越多，图就越稠密\n* **两者复杂度**\nKruskal:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/da9f37d33d494759b106faaed5b2672e.png)\nPrim:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e6b54fba62554c22acca6cfd1d407586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcyNzE4OA==,size_16,color_FFFFFF,t_70)","tags":["图论"]},{"title":"最短路","url":"/2021/09/20/最短路/","content":"\ndijskra floyd 最短路 最小环 负环与差分约束\n\n<!--more-->\n\n# 题单\n* [ ] [Shortest Path Query](https://codeforces.com/problemset/problem/1335/F)\n\n* **最短路需要考虑的几种情况**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/65ff2b2f8d2b4feba6b5f65cdf55b923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcyNzE4OA==,size_16,color_FFFFFF,t_70)\n\n# Dijkstra\n* **适用情况** 此算法不能用于求负权图，要求所有边的权重都为非负值。\n* **思路**  在最短路径的问题中，局部最优解即当前的最短路径或者说是在当前的已知条件下起点到其余各点的最短距离。\n* 邻接矩阵暴力模板 时间O(n*n)  \n\n```cpp\n//邻接矩阵做法,时间复杂度O(n*n)----------------------------------------------------------\n/*** \n * @Practice Win\n * HDU - 2544\n * 每次从dis[i]中选择最小的加入集合S\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e2+11;//最多顶点数！！！\nll dis[maxn],vis[maxn],gra[maxn][maxn];//自己到自己和不存在都视为INF\nll n,m,start,goal;\nll dijkstra(){//若图连通，返回最短路权值和，否则，返回一个未知值。\n\tfor(ll i=1;i<=n;i++){\n\t\tdis[i]=gra[start][i];\n\t}\n\tvis[start]=1;\n\tll pos;\n\tfor(ll i=2;i<=n;i++){\n\t\tll minn=INF;\n\t\tpos=-1;\n\t\tfor(ll j=1;j<=n;j++)  if(!vis[j] && dis[j]<minn)  minn=dis[j],pos=j;//顶点编号从1开始！！！\n\t\tif(pos==-1)  break;\n\t\tvis[pos]=1;\n\t\tfor(ll j=1;j<=n;j++)  if(!vis[j] && dis[pos]+gra[pos][j]<dis[j])  dis[j]=dis[pos]+gra[pos][j];//顶点编号从1开始！！！\n\t}\n\tif(pos==-1)  cout<<\"orz\"<<endl;\n\telse  cout<<dis[goal]<<endl;\n\treturn dis[goal];\n}\nvoid init(){\n\tmemset(gra,0x3f3f3f3f,sizeof(gra));\n\tmemset(vis,0,sizeof(vis));\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\twhile(cin>>n>>m && (n||m)){\n\t\tinit();\n\t\tstart=1,goal=n;\n\t\tfor(ll i=1;i<=m;i++){//顶点编号从1开始！！！\n\t\t\tll u,v,w;\n\t\t\tcin>>u>>v>>w;\n\t\t\tif(w<gra[u][v])  gra[u][v]=gra[v][u]=w;//无向图，包含重边情况取最小边考虑！！！\n\t\t}\n\t\tdijkstra();\n\t}\n    return 0;\n}\n```\n* 邻接矩阵优先队列优化 时间O(n*logn)\n\n```cpp\n//优先队列优化,时间复杂度O(n*logn)-----------------------------------------------------------------\n/*** \n * @Practice Win\n * 洛谷 P4779 【模板】单源最短路径（标准版）\n * 每次从dis[i]中选择最小的加入集合S\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e6+11;//最多边数！！！\nstruct Edge{\n    ll fr,to,w,next;\n}edge[maxn];\nstruct Point{\n    ll w,pos;\n    friend bool operator <(const Point& a,const Point& b){\n        return a.w>b.w;//优先队列这里是按值从高到低排序，所以得改为>，才变成从小到大排序\n    }\n};\nll dis[maxn],vis[maxn],head[maxn];//自己到自己和不存在都视为INF\nll n,m,start,goal,tmp;\npriority_queue<Point> dq;\nll dijkstra(){//若图连通，返回最短路权值和，否则，返回一个未知值。\n\tfor(ll i=head[start];~i;i=edge[i].next){\n        ll v=edge[i].to;\n\t\tdis[v]=min(dis[v],edge[i].w);\n        Point p;\n        p.pos=v;p.w=dis[v];\n        dq.push(p);\n\t}\n\tvis[start]=1;\n\tll pos;\n\tfor(ll i=2;i<=n;i++){\n        while(vis[dq.top().pos])  dq.pop();//考虑队列中有重边情况\n\t\tpos=dq.top().pos;\n        dq.pop();\n\t\tvis[pos]=1;\n\t\tfor(ll j=head[pos];~j;j=edge[j].next){\n            ll v=edge[j].to;\n            if(!vis[v] && dis[pos]+edge[j].w<dis[v]){\n                Point p;\n                dis[v]=dis[pos]+edge[j].w;//顶点编号从1开始！！！\n                p.pos=v;p.w=dis[v];\n                dq.push(p);\n            }  \n        }  \n\t}\n\treturn dis[goal];\n}\nvoid add(ll u,ll v,ll w){\n    edge[tmp].fr=u; edge[tmp].to=v; edge[tmp].w=w;\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid init(){\n\tmemset(head,-1,sizeof(head));\n    memset(dis,0x3f3f3f3f,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n    tmp=1;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tcin>>n>>m>>start;\n    init();\n    for(ll i=1;i<=m;i++){//顶点编号从1开始！！！\n        ll u,v,w;\n        cin>>u>>v>>w;\n        add(u,v,w);//有向图\n        //add(v,u,w);\n    }\n    dijkstra();\n    for(ll i=1;i<=n;i++){\n        if(start==i)  cout<<0<<\" \";\n        else  cout<<dis[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n}\n```\n\n# 最短路计数边无权值\n[P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)\n\n最短路计数，即最短路上每条边的重边个数的乘积，那么dp[v]=dp[u] * a（a为重边个数）,又因为1个点可以由多个点u到达，则dp[v]+=dp[u] * a;\n对于a，我们将重边加入edge中，每次<=dis时，因为有=号，所以重边会被加a次，就相当于dp[u]*a;\n又因为这道题里面每条边长度都为1，所有dis[v]被更新的过程中，都只会有1个值。**如果每条边长度不等,在dis[v]更新为一个更小值时，dp[v]要初始化为0。**\n\n```cpp\n\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll mo=100003;\nconst ll maxn=2e6+11;//最多边数！！！\nstruct Edge{\n    ll fr,to,w,next;\n}edge[maxn<<1];\nstruct Point{\n    ll w,pos;\n    friend bool operator <(const Point& a,const Point& b){\n        return a.w>b.w;//优先队列这里是按值从高到低排序，所以得改为>，才变成从小到大排序\n    }\n};\nll dis[maxn],vis[maxn],head[maxn],dp[maxn];//自己到自己和不存在都视为INF\nll n,m,start,tmp;\npriority_queue<Point> dq;\nvoid dijkstra(){//若图连通，返回最短路权值和，否则，返回一个未知值。\n    dq.push({0,start});dis[start]=0;dp[start]=1;\n    while(!dq.empty()){\n        ll pos=dq.top().pos;\n        dq.pop();\n        if(vis[pos]==1)  continue;\n        vis[pos]=1;\n        for(ll j=head[pos];j;j=edge[j].next){\n            ll v=edge[j].to;\n            if(!vis[v] && dis[pos]+edge[j].w<=dis[v]){\n                dp[v]=(dp[v]+dp[pos])%mo;\n                dis[v]=dis[pos]+edge[j].w;//顶点编号从1开始！！！\n                dq.push({dis[v],v});\n            }  \n        }  \n    }\n}\nvoid add(ll u,ll v,ll w){\n    edge[tmp].fr=u; edge[tmp].to=v; edge[tmp].w=w;\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid init(){\n    memset(head,0,sizeof(head));\n    memset(dis,0x3f3f3f3f,sizeof(dis));\n    memset(vis,0,sizeof(vis));\n    tmp=1;\n}\nint main(){\n    scanf(\"%lld%lld\",&n,&m);\n    start=1;\n    init();\n    for(ll i=1;i<=m;i++){//顶点编号从1开始！！！\n        ll u,v,w;\n        scanf(\"%lld%lld\",&u,&v);w=1;\n        add(u,v,w);//有向图\n        add(v,u,w);\n    }\n    dijkstra();\n    for(ll i=1;i<=n;i++){\n        printf(\"%lld\\n\",dp[i]);\n    }\n    return 0;\n}\n\n```\n\n# 最短路计数边有权值(不计权值相等边)\n[P1608 路径统计](https://www.luogu.com.cn/problem/P1608)\n\n```cpp\n\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxm=4e6+11;//最多边数！！！\nconst ll maxn=2e3+11;\nstruct Edge{\n    ll fr,to,w,next;\n}edge[maxm];\nstruct Point{\n    ll w,pos;\n    friend bool operator <(const Point& a,const Point& b){\n        return a.w>b.w;//优先队列这里是按值从高到低排序，所以得改为>，才变成从小到大排序\n    }\n};\nll dis[maxn],vis[maxn],head[maxn],dp[maxn],ar[maxn][maxn];//自己到自己和不存在都视为INF\nll n,m,start,goal,tmp;\npriority_queue<Point> dq;\nvoid dijkstra(){//若图连通，返回最短路权值和，否则，返回一个未知值。\n    dq.push({0,start});dis[start]=0;dp[start]=1;\n    while(!dq.empty()){\n        ll pos=dq.top().pos;\n        dq.pop();\n        if(vis[pos]==1)  continue;\n        vis[pos]=1;\n        for(ll i=head[pos];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(!vis[v] && dis[pos]+edge[i].w<=dis[v]){\n                if(dis[pos]+edge[i].w<dis[v])  dp[v]=0;\n                dp[v]+=dp[pos]; \n                dis[v]=dis[pos]+edge[i].w;//顶点编号从1开始！！！\n                dq.push({dis[v],v});\n            }  \n        }  \n    }\n}\nvoid add(ll u,ll v,ll w){\n    edge[tmp].fr=u; edge[tmp].to=v; edge[tmp].w=w;\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid init(){\n    memset(head,0,sizeof(head));\n    memset(dis,0x1f1f1f1f,sizeof(dis));\n    memset(vis,0,sizeof(vis));\n    tmp=1;\n}\nint main(){\n    scanf(\"%lld%lld\",&n,&m);\n    start=1;goal=n;\n    init();\n    for(ll i=1;i<=m;i++){//顶点编号从1开始！！！\n        ll u,v,w;\n        scanf(\"%lld%lld%lld\",&u,&v,&w);\n        if(ar[u][v]==0 || w<ar[u][v]){\n//此处不统计重边数量,即1 2 1 和 1 2 1算一条边。。。。！！！！！\n            add(u,v,w);\n            ar[u][v]=w;\n        }\n    }\n    dijkstra();\n    if(dis[goal]>1e9)  printf(\"No answer\\n\");\n    else  printf(\"%lld %lld\\n\",dis[goal],dp[goal]);\n    return 0;\n}\n```\n# 最短路计数边有权值（计重边\n\n```cpp\n\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxm=4e6+11;//最多边数！！！\nconst ll maxn=2e3+11;\nstruct Edge{\n    ll fr,to,w,next;\n}edge[maxm];\nstruct Point{\n    ll w,pos;\n    friend bool operator <(const Point& a,const Point& b){\n        return a.w>b.w;//优先队列这里是按值从高到低排序，所以得改为>，才变成从小到大排序\n    }\n};\nll dis[maxn],vis[maxn],head[maxn],dp[maxn];//自己到自己和不存在都视为INF\nll n,m,start,goal,tmp;\npriority_queue<Point> dq;\nvoid dijkstra(){//若图连通，返回最短路权值和，否则，返回一个未知值。\n    dq.push({0,start});dis[start]=0;dp[start]=1;\n    while(!dq.empty()){\n        ll pos=dq.top().pos;\n        dq.pop();\n        if(vis[pos]==1)  continue;\n        vis[pos]=1;\n        for(ll i=head[pos];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(!vis[v] && dis[pos]+edge[i].w<=dis[v]){\n                if(dis[pos]+edge[i].w<dis[v])  dp[v]=0;\n                dp[v]+=dp[pos];\n                dis[v]=dis[pos]+edge[i].w;//顶点编号从1开始！！！\n                dq.push({dis[v],v});\n            }  \n        }  \n    }\n}\nvoid add(ll u,ll v,ll w){\n    edge[tmp].fr=u; edge[tmp].to=v; edge[tmp].w=w;\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid init(){\n    memset(head,0,sizeof(head));\n    memset(dis,0x1f1f1f1f,sizeof(dis));\n    memset(vis,0,sizeof(vis));\n    tmp=1;\n}\nint main(){\n    scanf(\"%lld%lld\",&n,&m);\n    start=1;goal=n;\n    init();\n    for(ll i=1;i<=m;i++){//顶点编号从1开始！！！\n        ll u,v,w;\n        scanf(\"%lld%lld%lld\",&u,&v,&w);\n        add(u,v,w);//有向图\n    }\n    dijkstra();\n    if(dis[goal]>1e9)  printf(\"No answer\\n\");\n    else  printf(\"%lld %lld\\n\",dis[goal],dp[goal]);\n    return 0;\n}\n\n```\n\n# SPFA判断是否存在负环\n[P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)\n\n* 模板\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:33\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-22 21:21:38\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=6e3+11;\nstruct Edge{\n    ll fr,to,w,next;\n}edge[maxn];\nll head[maxn],cnt[maxn],vis[maxn],dis[maxn],tmp,n,start;\nqueue<ll> q;\nvoid add(ll u,ll v,ll w){\n    edge[tmp]={u,v,w};\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nll spfa(){\n    while(!q.empty())  q.pop();\n    cnt[start]=0;dis[start]=0;\n    q.push(start);vis[start]=1;\n    while(!q.empty()){\n        ll u=q.front();q.pop();\n        vis[u]=0;\n        for(ll i=head[u];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(dis[u]+edge[i].w<dis[v]){\n                dis[v]=dis[u]+edge[i].w;\n                cnt[v]=cnt[u]+1;\n                if(cnt[v]>=n)  return 0;\n                if(!vis[v]){\n                    q.push(v);vis[v]=1;\n                }\n            }\n        }\n    }\n    return 1;\n}\nvoid init(){\n    memset(head,0,sizeof(head));\n    memset(vis,0,sizeof(vis));\n    memset(dis,0x1f,sizeof(dis));\n    tmp=1;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca;cin>>ca;start=1;\n    while(ca--){\n        ll m;cin>>n>>m;\n        init();\n        for(ll i=1,u,v,w;i<=m;i++){\n            cin>>u>>v>>w;\n            add(u,v,w);\n            if(w>=0)  add(v,u,w);\n        }\n        if(spfa())  cout<<\"NO\"<<endl;\n        else  cout<<\"YES\"<<endl;\n    }\n    return 0;\n}\n\n```\n\n# SPFA-差分约束\n\n[P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)\na-b <= c 即a <= b+c,所以是**b向a建一条权值为c的单向边**。同时建立一个源点0，从0向每个点连一条权值为0的单向边。\n\n* 拓展\n很多时候差分约束的条件并不是简单的小于等于号，这时候我们需要稍微做点变形。\n如果有a-b >= c  则可以两边同时乘 -1，将不等号反转过来。\n如果有 a-b=c 则可以把这个等式拆分为 a-b <= c 和 a-b >= c 两个约束条件。\n\n如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成\"<=\"的形式，建图后求最短路；\n相反，如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成\">=\"，建图后求最长路。\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-23 12:04:28\n*/\n/*\n如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成\"<=\"的形式，建图后求最短路；\n相反，如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成\">=\"，建图后求最长路。\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=3e4+11;\nstruct Edge{\n    ll fr,to,w,next;\n}edge[maxn];\nll head[maxn],dis[maxn],vis[maxn],cnt[maxn],tmp,start,n;\nqueue<ll> q;\nvoid add(ll u,ll v,ll w){\n    edge[tmp]={u,v,w};edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nll spfa(){\n    dis[start]=0;cnt[start]=0;\n    q.push(start);vis[start]=1;\n    while(!q.empty()){\n        ll u=q.front();q.pop();vis[u]=0;\n        for(ll i=head[u];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(dis[u]+edge[i].w<dis[v]){\n                dis[v]=dis[u]+edge[i].w;\n                cnt[v]=cnt[u]+1;\n                if(cnt[v]>=n+1)  return 0;//此处为n+1，因为还有一个源点0！\n                if(!vis[v]){q.push(v);vis[v]=1;}\n            }\n        }\n    }\n    return 1;\n}\nvoid init(){\n    memset(dis,0x1f,sizeof(dis));\n    tmp=1;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    init();\n    ll m;cin>>n>>m;\n    for(ll i=1;i<=n;i++)  add(0,i,0);\n    for(ll i=1,u,v,w;i<=m;i++){\n        cin>>u>>v>>w;\n        add(v,u,w);//从v向u建边！！！\n    }\n    start=0;\n    if(spfa()){\n        for(ll i=1;i<=n;i++)  cout<<dis[i]<<\" \";\n    }\n    else  cout<<\"NO\"<<endl;\n    return 0;\n}\n\n```\n\n# 差分约束-区间\n\n[Intervals HDU - 1384 ](https://vjudge.net/contest/458535#problem/I)\n\n[转载题解](https://blog.csdn.net/weixin_43209425/article/details/104772812)\n\n注意区间用前缀和表示时，左端点是s[ l-1 ]，不是s[ l ]；\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-25 22:10:02\n*/\n#include<iostream>\n#include<cstring>\n#include<queue>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=5e4+11;\nstruct Edge{\n    ll to,w,next;\n}edge[maxn<<2];\nll head[maxn],dis[maxn],vis[maxn],tmp,start,goal;\nqueue<ll> q;\nvoid add(ll u,ll v,ll w){\n    edge[tmp]={v,w};edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid spfa(){\n    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));\n    while(!q.empty())  q.pop();\n    dis[start]=0;q.push(start);vis[start]=1;\n    while(!q.empty()){\n        ll u=q.front();q.pop();vis[u]=0;\n        for(ll i=head[u];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(dis[u]+edge[i].w>dis[v]){\n                dis[v]=dis[u]+edge[i].w;\n                if(!vis[v]){\n                    q.push(v);vis[v]=1;\n                }\n            }\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while(cin>>n){\n        memset(head,0,sizeof(head));tmp=1;\n        start=0,goal=-1;\n        for(ll i=1;i<=n;i++){\n            ll l,r,w;cin>>l>>r>>w;\n            goal=max(r,goal);\n            add(l-1,r,w);//注意左端点是s[l-1]，不是s[l]；\n        }\n        for(ll i=1;i<=goal;i++){\n            add(i-1,i,0);add(i,i-1,-1);\n        }\n        spfa();\n        cout<<dis[goal]<<endl;\n    }\n    return 0;\n}\n\n```\n\n## 差分约束-思维好题\n有N ≤ 3 e 3个格子，你可以任意给每个格子染色，但是要满足M ≤ 3 e 3限制条件，限制条件有两种类型：\n1.区间[ l , r ]中被染色的格子数量不少于K。\n\n2.区间[ l , r ]外被染色的格子数量不少于K。\n在满足所有限制条件下求染色格子数量的最小值。\n\n思路：此题关键在于条件2的处理，我们会发现s[ n ]-s[ r ]+s[ l-1 ]>=k,关键在于s[ n ]是未知的，然后n具有单调性，二分n再跑spfa即可。\n\n\n# Floyd\n* **适用情况** 适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）\n* **思路**  这个思想不太好解释，大概思路就是全局的一个维护最短路径，每次增加一个结点，进行一次全局的维护，当所有结点都增加时，得到一个全局的最短路径。因为每次增加一个结点，都是进行一个全局最短路径的维护，所以能够保证最后得到的是全局的最短路径。\n\nFloyd算法是基于动态规划的，从结点 i 到结点 j 的最短路径只有两种：\n1、直接 i 到 j\n2、i 经过若干个结点到 k 再到 j\n对于每一个k，我们都判断 d[i][j] 是否大于 d[i][k] + d[k][j]，如果大于，就可以更新d[i][j]了。\n\n* 模板\n```cpp\n/*** \n * @Practice Win\n */\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e2+11;\nll flo[maxn][maxn];\nll n,m;\nvoid floyd(){//flo初始化为一个邻接矩阵之后，即可调用，注意点的编号是否从1开始。\n    //flo[x][y]表示x到y的最短距离\n    for (ll k = 1; k <= n; k++) {//k必须放外层！！！\n        for (ll x = 1; x <= n; x++) {\n            for (ll y = 1; y <= n; y++) {\n                flo[x][y] = min(flo[x][y], flo[x][k] + flo[k][y]);\n            }\n        }\n    }\n}\nvoid init(){\n    memset(flo,0x3f3f3f3f,sizeof(flo));\n    for(ll i=1;i<=n;i++)  flo[i][i]=0;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>m;\n    init();\n    for(ll i=1;i<=m;i++){\n        ll a,b;\n        cin>>a>>b;\n        flo[a+1][b+1]=flo[b+1][a+1]=1;//无向图！！！因为是邻接矩阵！！！\n    }\n    floyd();\n    return 0;\n}\n\n```\n\n# floyd-最小环（至少三个不同点形成的环）\n[P6175 无向图的最小环问题](https://www.luogu.com.cn/problem/P6175)\n\n* 模板\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-22 13:36:10\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nll d[111][111],ar[111][111],minn=INF,n;\nvoid floyd(){\n    for(ll k=1;k<=n;k++){\n        for(ll i=1;i<=n;i++){\n            for(ll j=1;j<=n;j++){\n                if(i==j)  continue;\n                minn=min(minn,ar[k][i]+ar[k][j]+d[i][j]);//写在d[i][j]前面！排除掉k在i,j路径上的情况\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll m;cin>>n>>m;\n    memset(d,0x1f,sizeof(d));\n    memset(ar,0x1f,sizeof(ar));\n    for(ll i=1,u,v,l;i<=m;i++){\n        cin>>u>>v>>l;\n        if(l<d[u][v])  d[u][v]=d[v][u]=ar[u][v]=ar[v][u]=l;\n    }\n    floyd();\n    if(minn>1e9)  cout<<\"No solution.\"<<endl;\n    else  cout<<minn<<endl;\n    return 0;\n}\n\n```\n\n# floyd-最大环\n[Arbitrage HDU - 1217 ](https://vjudge.net/problem/HDU-1217)\n\n题意：判断图中是否存在最大环，使得边乘积>1\n\n最大环简单运用，把+变乘即可\n\n```cpp\n\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-22 11:41:36\n*/\n#include<iostream>\n#include<cstring>\n#include<map>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=2e5+11;\nll n;\ndouble d[33][33],maxx;\nvoid floyd(){\n    for(ll k=1;k<=n;k++){\n        for(ll i=1;i<=n;i++){\n            for(ll j=1;j<=n;j++){\n                d[i][j]=max(d[i][j],d[i][k]*d[k][j]);\n                if(i==j)  maxx=max(d[i][j],maxx);\n            }\n        }\n    }\n}\nvoid init(){\n    memset(d,0,sizeof(d));\n    maxx=0;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca=0;\n    while(cin>>n && n){\n        init();\n        map<string,ll> mp;\n        for(ll i=1;i<=n;i++){\n            d[i][i]=1;\n            string sr;cin>>sr;\n            mp[sr]=i;\n        }\n        ll m;cin>>m;\n        for(ll i=1;i<=m;i++){\n            string sr1,sr2;double w;\n            cin>>sr1>>w>>sr2;\n            ll u=mp[sr1],v=mp[sr2];\n            d[u][v]=w;//重边？\n        }\n        floyd();\n        cout<<\"Case \"<<++ca<<\": \";\n        if(maxx>1)  cout<<\"Yes\"<<endl;\n        else  cout<<\"No\"<<endl;\n    }\n    return 0;\n}\n\n```\n\n# 灵活运用（最短路建图+弱思维）\n**题目链接**  https://vjudge.net/problem/POJ-1062\n**题意**  \n  小花想娶部落里的王子 王子的父亲要求一定数量的金币才能娶  \n  困窘的小花还有另外一条出路就是得到另外一件东西与王子的父亲交换 以此来减少金币  \n  同理 可以由别的东西来换取现在需要的东西的优惠 \n  另一个限制条件就是 等级相差k的人不能进行交易 即使是间接交易\n **思路**\n 关键在于建图，以及对等级限制的处理\n 物品的交换流程可以构成一个有向图，而且这个图是有边权的。\n  于是就转化为（求各点到源点最短的距离+各点本身价格）的最小值\n  枚举每个结点即可。\n  关于等级限制\n  在Dijkstra期间将违背等级的点之间的边权设为无限大即可，表示不可访问\n  \n\n```cpp\nll dijkstra(){//若图连通，返回最短路权值和，否则，返回一个未知值。\n\tfor(ll i=1;i<=n;i++){\n\t\tdis[i]=gra[start][i];\n\t\tlevell[i]=min(l[1],l[i]);\n\t\tlevelr[i]=max(l[1],l[i]);\n        if(abs(l[i]-l[1])>m)  dis[i]=INF;//路径上的等级极值差如果大于m\n\t}\n\tvis[start]=1;\n\tll pos;\n\tfor(ll i=2;i<=n;i++){\n\t\tll minn=INF;\n\t\tpos=-1;\n\t\tfor(ll j=1;j<=n;j++)  if(!vis[j] && dis[j]<minn)  minn=dis[j],pos=j;//顶点编号从1开始！！！\n\t\tif(pos==-1)  break;\n\t\tvis[pos]=1;\n\t\tfor(ll j=1;j<=n;j++){\n            if(!vis[j] && dis[pos]+gra[pos][j]<dis[j]){//顶点编号从1开始！！！\n                dis[j]=dis[pos]+gra[pos][j];\n\t\t\t\tlevell[j]=min(levell[pos],l[j]);\n\t\t\t\tlevelr[j]=max(levelr[pos],l[j]);\n                if(levelr[j]-levell[j]>m)  dis[j]=INF;//路径上的等级极值差如果大于m\n            }\n        }    \n\t}\n    return 1;\n}\n```\n\n# 灵活运用（弱思维）\n**题目链接**  https://www.luogu.com.cn/problem/P1364\n**题意**  设有一棵二叉树，如图：其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小\n**思路** floyd运用下就行了\n```cpp\n/*** \n * @Practice Win\n * 洛谷 P1364 医院设置\n * floyd \n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e2+11;\nll flo[maxn][maxn],cnt[maxn];\nll n;\nvoid floyd(){//flo初始化为一个邻接矩阵之后，即可调用，注意点的编号是否从1开始。\n    //flo[x][y]表示x到y的最短距离\n    for (ll k = 1; k <= n; k++) {\n        for (ll x = 1; x <= n; x++) {\n            for (ll y = 1; y <= n; y++) {\n                flo[x][y] = min(flo[x][y], flo[x][k] + flo[k][y]);\n            }\n        }\n    }\n}\nvoid solve(){\n    ll ans=INF;\n    for(ll i=1;i<=n;i++){\n        ll minn=0;\n        for(ll j=1;j<=n;j++){\n            minn+=cnt[j]*flo[i][j];\n        }\n        ans=min(ans,minn);\n    }\n    cout<<ans<<endl;\n}\nvoid init(){\n    memset(flo,0x3f3f3f3f,sizeof(flo));\n    for(ll i=1;i<=n;i++)  flo[i][i]=0;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    init();\n    for(ll i=1;i<=n;i++){\n        cin>>cnt[i];\n        ll l,r;\n        cin>>l>>r;\n        flo[i][l]=flo[l][i]=1;\n        flo[i][r]=flo[r][i]=1;\n    }\n    floyd();\n    solve();\n    return 0;\n}\n\n\n```\n\n# 理解dijskra优先队列代码\n[最短路径问题 HDU - 3790](https://vjudge.net/problem/HDU-3790/origin)\n题意：给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。(1<n<=1000, 0<m<100000, s != t)\n\n思路：在优先队列里选则**路径**时，选择距离最短且花费最小的路径即可。注意代码细节\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-20 20:58:32\n*/\n\n#include<iostream>\n#include<cstring>\n#include<queue>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e5+11;\nstruct Edge{\n    ll fr,to,l,w,next;\n}edge[maxn<<1];\nll head[maxn],dis[maxn],vis[maxn],cost[maxn],tmp=1,start,goal,n,m;\nvoid add(ll u,ll v,ll l,ll w){\n    edge[tmp]={u,v,l,w};\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nstruct Point{\n    ll l,w,to;\n    bool operator < (const Point &b)  const{\n        if(l==b.l)  return w>b.w;\n        return l>b.l;\n    }\n};\npriority_queue<Point> qu;\nvoid dijkstra(){\n    qu.push({0,0,start});dis[start]=0,cost[start]=0;\n    while(!qu.empty()){\n        ll to=qu.top().to;qu.pop();\n        if(vis[to])  continue;\n        vis[to]=1;\n        for(ll i=head[to];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(!vis[v] && dis[to]+edge[i].l<=dis[v]){//每次选最短且花费最小的路径，要加=号！！！！\n                cost[v]=cost[to]+edge[i].w;\n                dis[v]=dis[to]+edge[i].l;\n                qu.push({dis[v],cost[v],v});//这里是cost[v],即到v点的路径花费  \n            }\n        }\n    }\n}\nvoid init(){\n    memset(dis,0x3f,sizeof(dis));\n    memset(head,0,sizeof(head));memset(vis,0,sizeof(vis));\n    tmp=1;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin>>n>>m && (n||m)){\n        init();\n        for(ll i=1,u,v,l,w;i<=m;i++){\n            cin>>u>>v>>l>>w;\n            add(u,v,l,w);add(v,u,l,w);\n        }\n        cin>>start>>goal;\n        dijkstra();\n        cout<<dis[goal]<<\" \"<<cost[goal]<<endl;\n    }\n    return 0;\n}\n\n```\n\n# dij思维好题\n[Shortest Path Query](https://codeforces.com/problemset/problem/1335/F)\n\n题意：给定一个图，图中每一条边的两点符合以下条件：两点编号二进制表示下一个位另一个的前缀。给出q次询问，每次给出u，v，询问u和v之间的最短路。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n思路：求b,c两点的最短路径，直接floyd肯定不行。注意到题目前缀这一性质，若b,c可达，\n则b，c肯定存在一共同前缀a,则b，c之间的距离即为(a,b)+(a,c)。\n若b < c，可以枚举b的前缀，logb个，再求min((a,b)+(a,c))即可。\n那么如何求(a,b)和(a,c)呢，直接对所有点求一遍dij肯定不行，思考观察后不难发现，\n我们可以求(b,a)和(c,a)，b和c的祖先结点logn个，则我们存下所有点到其祖先节点的距离即可。\n\n  </code></pre>\n</details>\n\n代码，wa了，不知道wa在哪了。。，改了一下午没改出来。。\n好心人若找出错误了一定告诉我(qiuqiule)\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-21 16:34:07\n*/\n/*\n求b,c两点的最短路径，直接floyd肯定不行。注意到题目前缀这一性质，若b,c可达，\n则b，c肯定存在一共同前缀a,则b，c之间的距离即为(a,b)+(a,c)。\n若b<c，可以枚举b的前缀，logb个，再求min((a,b)+(a,c))即可。\n那么如何求(a,b)和(a,c)呢，直接对所有点求一遍dij肯定不行，思考观察后不难发现，\n我们可以求(b,a)和(c,a)，b和c的祖先结点logn个，则我们存下所有点到其祖先节点的距离即可。\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x3f3f3f3f3f3f3f3f\ntypedef long long ll;\nconst ll maxn=2e5+11;\nstruct Edge{\n    ll fr,to,l,next;\n}edge[maxn];\nll head[maxn],dis[maxn][22],tmp=1;\nstruct Point{\n    ll l,p;\n    bool operator < (const Point& b) const {\n        return l>b.l;\n    }\n};\npriority_queue<Point> qu;\nvoid add(ll u,ll v,ll l){\n    edge[tmp]={u,v,l};\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nll shu(ll x){\n    for(ll i=1;i<=20;i++)  if(x>>i==0)  return i;\n}\nll check(ll a,ll b){//判断a为b的前缀\n    for(ll i=1;i<=20;i++)  if(b>>i==a)  return 1;\n    return 0;\n}\nvoid dijkstra(ll root){\n    ll vis[22];\n    memset(vis,0,sizeof(vis));\n    ll num=shu(root);\n    qu.push({0,root});dis[root][num]=0;\n    while(!qu.empty()){\n        ll pos=qu.top().p;qu.pop();\n        ll nn=shu(pos);\n        if(vis[nn]==1)  continue;\n        vis[nn]=1;\n        for(ll i=head[pos];i;i=edge[i].next){\n            ll v=edge[i].to;ll nnn=shu(v);\n            if(check(v,root)==0)  continue;\n            if(dis[root][nn]+edge[i].l<dis[root][nnn]){\n                dis[root][nnn]=dis[root][nn]+edge[i].l;\n                qu.push({dis[root][nnn],v});\n            }\n        }\n    }\n}\nvoid solve(ll b,ll c){\n    if(b>c)  swap(b,c);\n    ll ans=INF;\n    ll in=1;\n    if(check(b,c))  in=0;\n    for(ll i=in;i<=20;i++){\n        ll a=b>>i;ll num=shu(a);\n        ans=min(ans,dis[b][num]+dis[c][num]);\n    }\n    if(ans==INF)  cout<<-1<<endl;\n    else  cout<<ans<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    memset(dis,0x3f,sizeof(dis));\n    ll n,m;cin>>n>>m;\n    for(ll i=1,u,v,l;i<=m;i++){\n        cin>>v>>u>>l;\n        add(u,v,l);\n    }\n    for(ll i=1;i<=n;i++)  dijkstra(i);\n    ll q;cin>>q;\n    while(q--){\n        ll b,c;cin>>b>>c;\n        solve(b,c);\n    }\n    return 0;\n}\n\n```\n\n# dij思维好题\n\n[Silver Cow Party](https://vjudge.net/problem/POJ-3268)\n\n[转载题解](https://www.cnblogs.com/Jason-Damon/archive/2012/04/29/2476285.html)\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-21 18:59:30\n*/\n#include<iostream>\n#include<cstring>\n#include<queue>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e5+11;\nstruct Edge{\n    ll fr,to,t,next;\n}edge[maxn];\nll head[maxn],fr[maxn],to[maxn],t[maxn],vis[maxn],disf[maxn],diss[maxn],tmp,root;\nstruct Point{\n    ll l,p;\n    bool operator < (const Point& b) const{\n        return l>b.l;\n    }\n};\npriority_queue<Point> qu; \nvoid add(ll u,ll v,ll t){\n    edge[tmp]={u,v,t};\n    edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid dijkstra1(){\n    qu.push({0,root});disf[root]=0;\n    while(!qu.empty()){\n        ll u=qu.top().p;qu.pop();\n        if(vis[u]==1)  continue;\n        vis[u]=1;\n        for(ll i=head[u];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(disf[u]+edge[i].t<disf[v]){\n                disf[v]=disf[u]+edge[i].t;\n                qu.push({disf[v],v});\n            }\n        }\n    }\n}\nvoid dijkstra2(){\n    qu.push({0,root});diss[root]=0;\n    while(!qu.empty()){\n        ll u=qu.top().p;qu.pop();\n        if(vis[u]==1)  continue;\n        vis[u]=1;\n        for(ll i=head[u];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(diss[u]+edge[i].t<diss[v]){\n                diss[v]=diss[u]+edge[i].t;\n                qu.push({diss[v],v});\n            }\n        }\n    }\n}\nvoid init(){\n    memset(head,0,sizeof(head));tmp=1;\n    memset(vis,0,sizeof(vis));\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n,m;cin>>n>>m>>root;\n    for(ll i=1;i<=m;i++){\n        cin>>fr[i]>>to[i]>>t[i];\n    }\n    init();memset(disf,0x3f,sizeof(disf));\n    for(ll i=1;i<=m;i++){\n        add(fr[i],to[i],t[i]);\n    }\n    dijkstra1();\n    init();memset(diss,0x3f,sizeof(diss));\n    for(ll i=1;i<=m;i++){\n        add(to[i],fr[i],t[i]);\n    }\n    dijkstra2();\n    ll ans=0;\n    for(ll i=1;i<=n;i++){\n        if(i==root)  continue;\n        ans=max(ans,disf[i]+diss[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n```\n\n# dij灵活运用(思维一般)\n\n[Delay Constrained Maximum Capacity Path HDU - 1839](https://vjudge.net/contest/458535#problem/G)\n\n题意：求一条从1到n容量最大，时间在t以内的路径。路径容量是指路径上的最小边，t是路径上每条边的时间总和。\n每条边四个参数，u,v，容量，花费时间。(n < 1e4,m < 5e4);\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n一开始想的，这不就dfs嘛，然后跑了一遍发现超时了，也对，这种有环图dfs复杂度惊人。\n然后想到二分边长建图，把每次>mid的边建图，看dis[ n ]是否 <= t;\n \n  </code></pre>\n</details>\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-23 19:34:35\n*/\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e5+11;\nstruct Edge{\n    ll to,w,t,next;\n}edge[maxn];\nll ar[maxn],head[maxn],dis[maxn],vis[maxn],u[maxn],v[maxn],w[maxn],t[maxn];\nll n,m,total,tmp,start,goal,step;\nstruct Point{\n    ll w,pos;\n    bool operator < (const Point& b) const{\n        return w>b.w;\n    }\n};\npriority_queue<Point> dq;\nvoid add(ll u,ll v,ll w,ll t){\n    edge[tmp]={v,w,t};edge[tmp].next=head[u];\n    head[u]=tmp++;\n}\nvoid dijkstra(){\n    dis[start]=0;\n    dq.push({0,start});\n    while(!dq.empty()){\n        ll u=dq.top().pos;dq.pop();\n        if(vis[u]==1)  continue;\n        vis[u]=1;\n        for(ll i=head[u];i;i=edge[i].next){\n            ll v=edge[i].to;\n            if(!vis[v] && dis[u]+edge[i].t<dis[v]){\n                dis[v]=dis[u]+edge[i].t;\n                dq.push({dis[v],v});\n            }\n        }\n    }\n}\nvoid init(){\n    memset(head,0,sizeof(head));memset(dis,0x1f,sizeof(dis));\n    memset(vis,0,sizeof(vis));\n}\nll check(ll mid){\n    tmp=1;init();\n    for(ll i=1;i<=m;i++){\n        if(w[i]>=ar[mid]){\n            add(u[i],v[i],w[i],t[i]);add(v[i],u[i],w[i],t[i]);\n        }\n    }\n    dijkstra();\n    if(dis[goal]<=total)  return 1;\n    else  return 0;\n}\nvoid solve(){\n    ll l=0,r=step;\n    while(l<r){\n        ll mid=(l+r)>>1;\n        if(check(mid))  r=mid;\n        else  l=mid+1;\n    }\n    cout<<ar[l]<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca;cin>>ca;\n    while(ca--){\n        cin>>n>>m>>total;\n        start=1;goal=n;step=0;\n        for(ll i=1;i<=m;i++){\n            cin>>u[i]>>v[i]>>w[i]>>t[i];\n            ar[i-1]=w[i];\n        }\n        step=m;\n        sort(ar,ar+step,greater<ll>());\n        solve();\n    }\n    return 0;\n}\n\n```\n","tags":["图论"]},{"title":"图的遍历","url":"/2021/09/20/图的遍历/","content":"\ndfs bfs ..\n\n<!--more-->\n\n# dfs\ndfs需要解决的最关键问题：\n当无法继续往下遍历时，如何回退到上一步\n方法：看到关键字回退，应该想到递归，递归就是一步步往下处理，处理到末尾再一步步回退，与dfs很契合\n对于dfs过程中的结点，有先入后出的特点，FILO,即栈。\n（栈这里不懂看这篇https://blog.csdn.net/saltriver/article/details/54429068）\n下面演示用dfs数出图中与源点距离大于d的点的个数\n```cpp\nvoid dfs(ll u,ll step){\n    if(step>d)  ans++;\n    for(ll i=head[u];i!=-1;i=edge[i].next){//链式前向星存储\n        dfs(edge[i].to,step+1);\n    }\n    return ;\n}\n```\n# 灵活运用(dfs思维好题)\n**题目链接**  https://www.luogu.com.cn/problem/P3916\n**题意**  给出N个点，M条边的有向图，对于每个点v，求A(v)表示从点v出发，能到达的编号最大的点。\n**思路**  编号最大的点，我们不妨**从最大的点开始遍历**，**反向建边**，这样子从最大的点遍历到的所有点，就都是以该点作为最大值\n\n# 灵活运用（较简单dfs）\n**题目链接**  https://www.luogu.com.cn/problem/P1123\n**题意** 一个N×M的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻8个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。\n对于100%的数据，N, M≤6,T≤20，T是样例数\n**思路** 简单dfs\n# 灵活运用（dfs思维好题）\n**题目链接**  https://ac.nowcoder.com/acm/contest/188/C?&headNav=www&headNav=acm&headNav=acm&headNav=acm\n**题意**  小w有一张n个点n-1条边的无向联通图,每个点编号为1~n,每条边都有一个长度，小w现在在点x上，她想知道从点x出发经过每个点至少一次，最少需要走多少路\n**思路**  只有从起点到各个结点中，最长的那个路径需要走一次，其他路径都需要走两次\n\n```cpp\nvoid dfs(ll u,ll uu,ll length){\n      ans=max(ans,length);\n      for(ll i=head[u];~i;i=edge[i].next){\n          if(edge[i].to==uu)  continue;\n          dfs(edge[i].to,u,length+edge[i].w);\n      }\n}\n```\n# 灵活运用（细节dfs）\n**题目链接**  https://vjudge.net/problem/HDU-2821\n**题意**  有一个R*C的方格，‘.’代表空地，‘a~z’分别代表该处有1~26个箱子，某人可以从距离箱子至少一个空格处推箱子，推一次此处少一个箱子，如果这个格还有其他箱子，则和它下一个格的箱子合并或到下一个格，朝着某个方向一直推到边界或者遇到箱子不能推为止（即箱子数多于1的堆在边界）才可以换方向，任意输出一种可以把箱子推完的方案，输出推箱子时起点的位置以及推箱子时的方向。\n注意：①起点不能有箱子。②必须要隔一个位置才能碰。③碰的箱子在边上时，剩下的箱子不能移出矩形范围。④格子在边上时，碰之后如果还有格子剩余，pusher的位置就不在边上，否则就在边上。\n**思路** 细节dfs，先预处理下，将'.'换成数字0,abcd换成对应数字即可\n**踩坑** **别用getchar()一个个读入处理，容易出错！！！**\n**小技巧** **双重循环还可以这样退出！！！**\n```cpp\nll dfs(ll x,ll y,ll cnt,string s,ll d,ll b){//d 1 2 3 4,上右下左，b为间隙数。dfs找到返回1，否则返回0\n    if(x<1 || x>r || y<1 || y>c)  return 0;//当前越界\n    if(cnt==0){//箱子全部清除\n        outs=s;\n        return 1;\n    }  \n    if(d==0){//d为0，选择方向\n        for(ll i=1;i<=4;i++){\n            if(dfs(x+dir[i][0],y+dir[i][1],cnt,s+ar[i],i,b+1))  return 1;\n        }\n    }\n    else{//d不为0\n        if(gra[x][y]==0){//当前位置是道路\n            if(dfs(x+dir[d][0],y+dir[d][1],cnt,s,d,b+1))  return 1;\n        }  \n        else{//当前位置是与木块重合，即撞到木块，\n            if(b<2)  return 0;//如果没有间隙，即必须要隔一个位置才能碰\n            if(x+dir[d][0]<1 || x+dir[d][0]>r || y+dir[d][1]<1 || y+dir[d][1]>c){//如果后面是边界\n                ll t=gra[x][y];\n                if(t>1)  return 0;//如果箱子数比1多\n                gra[x][y]=0;\n                if(dfs(x,y,cnt-1,s,0,0))  return 1;\n                gra[x][y]=1;\n            }\n            else{//如果后面不是边界\n                ll t=gra[x][y];\n                gra[x][y]=0;\n                gra[x+dir[d][0]][y+dir[d][1]]+=t-1;\n                if(dfs(x,y,cnt-1,s,0,0))  return 1;\n                gra[x][y]=t;//回溯\n                gra[x+dir[d][0]][y+dir[d][1]]+=1-t;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# bfs\n结点性质符合FIFO，即队列\n```cpp\n放入0点到队列里。\nwhile（队列不为空）{\n        取出队列里的一个点为A。\n        弹出A\n    for（遍历A点所有相连的点）{\n        if(该点没有被访问过) {\n        记录该点访问过\n        该点入队列\n        }\n    }\n}\n\n```\n","tags":["图论"]},{"title":"图论基础","url":"/2021/09/20/图论基础/","content":"\n存图=\n\n<!--more-->\n\n（邻接矩阵只适用于没有重边（或重边可以忽略）的情况，一般情况下不用考虑）\n* **邻接矩阵**\n\n>  空间复杂度高：O(n^2) \n   查询一条边的存在情况快： O(1)\n   遍历一个点的所有出边 ：O(n) \n    遍历整个图 ：O(n^2)\n* **邻接表**\n>空间复杂度低 ：为O(m) m为边数\n查询某条边 ： O(d+(u))即这个点的边数 ，如果边有排序，则通过二分就是O(log d+(u)) log边数的事件。\n遍历一个点的所有出边 ：O(d+(u))即该点的边数\n遍历整个图 ：O(n+m) 事件为点的个数加边数。\n* 链式前向星\n与邻接表基本一致。\n优点是边有编号（在更厉害点的算法中有用）\n","tags":["图论"]},{"title":"XTU自动打卡","url":"/2021/09/17/XTU自动打卡/","content":"\nXTU每天自动健康打卡  真香！\n<!--more-->\n\n[转载](https://www.bilibili.com/video/BV1fU4y1x7tA)\n","tags":["工具"]},{"title":"atom","url":"/2021/09/15/atom/","content":"\natom给我的第一感觉，无疑是惊艳的，较轻量，简洁而不失美观，很方便的分屏，插件安装十分方便，并且插件在GitHub都有详细介绍\n\n<!--more-->\n\n可惜没找到一键添加文件头部注释（懒得敲那一堆include,define）和代码自动补全（指敲个string sr,sr.后面不出来东西）的插件，有点可惜。\n\n# 我安装的一些插件\n\nlinter-gcc              gcc语法错误检查\nlinter                  语法错误检查\ngcc-make-run            C++F6一键编译运行\nHighlight Selected      相同变量高亮\nminimap                 右上角一个全部代码缩略图\natom-file-icons         好看的文件图标\nactivate-power-mode     代码连击，敲代码？音游！\n\n# 有好用的插件一起交流呀&#x1F60F;\n\n","tags":["工具"]},{"title":"搜索","url":"/2021/09/13/搜索/","content":"\ndfs bfs ...\n<!--more-->\n\n# DFS\n## 模板1\n需要标记相关信息时使用这种做法\n且搜索到满足条件的会继续搜索，不会停止\n```cpp\nint check(参数)\n{\n    if(满足条件)\n        return 1;\n    return 0;\n}\n \nvoid dfs(int step)\n{\n        判断边界\n        {\n            相应操作\n        }\n        尝试每一种可能\n        {\n               满足check条件\n               标记\n               继续下一步dfs(step+1)\n               恢复初始状态（回溯的时候要用到）\n        }\n}   \n```\n## 例题\n**题目链接**  https://www.luogu.com.cn/problem/P1123\n**题意**   一个N×M的由非负整数构成的数字矩阵，你需要在其中取出若干个数字， 使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻8个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。\n对于100%的数据，N, M≤6,T≤20，T是样例数\n* **注意细节**\n```cpp\n/*** \n * @Practice Win\n * 洛谷 P1123 取数游戏 \n * dfs \n * 思路 简单dfs\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nll ar[11][11],vis[11][11],d[11][2]={-1,0,-1,1,0,1,1,1,1,0,1,-1,0,-1,-1,-1,0,0};\n//方向数组，便于对x周围的八个数操作，很巧妙！！！\nll n,m,ans=0,maxx=0;\nvoid dfs(ll x,ll y){\n    if(y==m+1){\n        dfs(x+1,1);\n        return ;\n    }\n    if(x==n+1){\n        ans=max(ans,maxx);\n        return ;\n    }\n    dfs(x,y+1);\n    if(vis[x][y]==0){\n        maxx+=ar[x][y];\n        for(ll i=0;i<=8;i++){\n            vis[x+d[i][0]][y+d[i][1]]++;//这里是++，不能是=1，因为一个数可能会被多次标记为不可访问\n        }\n        dfs(x,y+1);\n        for(ll i=0;i<=8;i++){\n            vis[x+d[i][0]][y+d[i][1]]--;\n        }\n        maxx-=ar[x][y];\n    }\n}\nvoid init(){\n    memset(vis,0,sizeof(vis));\n    ans=maxx=0;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll t;\n    cin>>t;\n    while(t--){\n        init();\n        cin>>n>>m;\n        for(ll i=1;i<=n;i++){\n            for(ll j=1;j<=m;j++)  cin>>ar[i][j];\n        }\n        dfs(1,1);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n\n```\n\n## 模板2\n不需要标记相关结点信息时可以用这种写法\n这种在搜索到第一个满足条件的结果就会停止搜索\n```cpp\nbool dfs(ll step){\n    if(step==n)  return true;//达到边界\n    for(//遍历n个结点){\n        if(dfs(step+1))  return ture;//满足则停止搜索\n    }\n    return false;\n}\n```\n\n# 回溯法\n其实我觉得更好理解的就是，如果当前条件已经不满足了，就不再往下继续找了，我觉得叫剪枝更合适吧。回溯？还要往回找？什么东东，搜索本身不久包括了回溯嘛，这名字取得确实误导人。","tags":["数据结构"]},{"title":"我的hexo配置","url":"/2021/09/11/我的hexo配置/","content":"\n我的一些hexo配置\n\n<!--more-->\n\n首先感谢zhb，wyq带我入门，hb兄还不嫌弃的让我用了跟他同样一个主题Stun，我保证，有时间我会换一个主题\n当初用这个主题Stun的原因有二：1是美观简介 2是有新手文档，对我这种刚接触的新手十分友好\n\n# Stun主题\n\n## 评论功能\n我用的是Gitalk\n[安装使用请见Stun配置文档](https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F)\n\n## 友链功能\n[方法](https://zhuanlan.zhihu.com/p/384472746)\n\n## 点击查看思路/代码功能\n\n在文章中加入以下这段模板即可\n\n```html\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n    填写你的具体思路\n  </code></pre>\n</details>\n\n```\n\n## 搜索功能\n在Stun主题下添加搜索功能，很简单\n[参照Stun配置文档即可](https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2)\n\n## 文章按更新时间排序\n\n背景：由于home页按文章创建时间排序，但有些文章创建的比较早，在home页排得很靠后，却经常需要修改，十分麻烦。\n找了很多解决办法，也去github看了相关讨论，提问，没有合适的解决方法，大概就是说hexo本身不提供这个功能，这个功能需要插件或主题自带，所以暂且放弃。不过有个类似文章置顶功能，就是文章头部sticky属性，sticky权值越大，排名越靠前\n\n","tags":["工具"]},{"title":"Sublime","url":"/2021/09/10/Sublime/","content":"\n我的Sublime的一些配置\n\n<!--more-->\n\n环境：Win10 Sublime 4\n\n# 命令一键文件重定向输入输出\n\n优化日志：\n1.能够将输入输出重定向到文件\n2.自动关闭output时出现的cmd窗口\n3.一个命令编译并运行\n4.添加快捷键一键编译运行\n\n## 输入输出重定向到文件\n简介：设置命令，一键让程序从std.in读入，输出到std.out。\n\n背景：由于Acmer总是需要样例的输入与输出，如果样例输入很多，输出与样例混杂在一起，会比较难看。\n这个时候就需要将输入输出重定向到文件\n\n[转载，觉得谢大写得好的可以投个币](https://ericxie.github.io/2021/07/18/sublime-gcc/)\n\n## 自动关闭output时出现的cmd窗口\n由于每次output输出到文件时，都会出现cmd这个黑框框，需要手动删掉，十分麻烦，下面代码就是自动关掉这个cmd黑框框，不过还是会闪一下。\n把run.bat改为\n\n```bat\n@echo off\n \nif \"%time:~0,2%\" lss \"10\" (SET HOUR=%time:~1,1%) else (SET HOUR=%time:~0,2%)\nif \"%time:~3,2%\" lss \"10\" (SET MINUTE=%time:~4,1%) else (SET MINUTE=%time:~3,2%)\nif \"%time:~6,2%\" lss \"10\" (SET SECOND=%time:~7,1%) else (SET SECOND=%time:~6,2%)\nif \"%time:~9,2%\" lss \"10\" (SET MILLISECIOND=%time:~10,1%) else (SET MILLISECIOND=%time:~9,2%)\nset /a START=%HOUR%*3600*100+%MINUTE%*60*100+%SECOND%*100+%MILLISECIOND%\n%1 <%2 >%3\nif \"%time:~0,2%\" lss \"10\" (SET HOUR=%time:~1,1%) else (SET HOUR=%time:~0,2%)\nif \"%time:~3,2%\" lss \"10\" (SET MINUTE=%time:~4,1%) else (SET MINUTE=%time:~3,2%)\nif \"%time:~6,2%\" lss \"10\" (SET SECOND=%time:~7,1%) else (SET SECOND=%time:~6,2%)\nif \"%time:~9,2%\" lss \"10\" (SET MILLISECIOND=%time:~10,1%) else (SET MILLISECIOND=%time:~9,2%)\nset /a END=%HOUR%*3600*100+%MINUTE%*60*100+%SECOND%*100+%MILLISECIOND%\nset /a TOTAL=(%END%-%START%)*10\necho.\necho Run time : %TOTAL% ms\n\nif \"%1\" == \"h\" goto begin\nmshta vbscript:createobject(\"wscript.shell\").run(\"\"\"%~nx0\"\" h\",0)(window.close)&&exit\n:begin\nREM\n```\n\n如果不需要runtime这个信息，run.bat改为如下即可\n\n```bat\n@echo off\n%1 <%2 >%3\nif \"%1\" == \"h\" goto begin\nmshta vbscript:createobject(\"wscript.shell\").run(\"\"\"%~nx0\"\" h\",0)(window.close)&&exit\n:begin\nREM\n```\n\n## 一个命令编译并运行\n由于每次需要先点g++编译再点run或output运行，十分麻烦，那么可不可以一个命令让编译并运行呢？答案是肯定的，代码如下\n\n```cpp\n{\n    \"working_dir\": \"${file_path}\",\n    \"cmd\": [\"g++\",  \"${file}\", \"-o\", \"${file_base_name}.exe\", \"-lm\", \"-Wall\", \"-O2\",\"-std=gnu++11\",\"-Wl,--stack,100000000\"],\n    \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\",    \n    \"selector\": \"source.c\",\n    \"shell\": true,\n    \"variants\":\n    [\n       {\n            \"name\": \"Run\",\n            \"shell_cmd\": \"g++ -Wall -std=c++11 \\\"$file\\\" -o \\\"$file_base_name\\\" && start cmd /c \\\"${file_path}/${file_base_name} & pause\\\"\"\n       },\n       {\n            \"name\": \"Output\",       \n            \"cmd\": [\"g++\", \"-Wall\",\"${file}\", \"-o\", \"${file_path}/${file_base_name}\", \"&&\", \"start\",\"/D ${file_path}\",\"run.bat\",\"${file_base_name}.exe\",\"std.in\",\"std.out\"]\n       },\n    ]\n}\n```\n\n## 快捷键一键编译运行\n我不想每次ctrl+shift+b来选择命令运行，太麻烦了，那么能不能设置个快捷键呢？答案是肯定的，方法如下：\n在sumlime点击preferences->key bindings\n然后在里面加上以下代码即可：\n\n```cpp\n[\n\t{\"keys\": [\"f9\"], \"command\": \"build\", \"args\": {\"variant\": \"Run\"}},\n\t{\"keys\": [\"f10\"], \"command\": \"build\", \"args\": {\"variant\": \"Output\"}}  \n]\n\n```\n\n## 最终配置\ng++.sublime-build:\n\n```cpp\n{\n    \"working_dir\": \"${file_path}\",\n    \"cmd\": [\"g++\",  \"${file}\", \"-o\", \"${file_base_name}.exe\", \"-lm\", \"-Wall\", \"-O2\",\"-std=gnu++11\",\"-Wl,--stack,100000000\"],\n    \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\",    \n    \"selector\": \"source.c\",\n    \"shell\": true,\n    \"variants\":\n    [\n       {\n            \"name\": \"Run\",\n            \"shell_cmd\": \"g++ -Wall -std=c++11 \\\"$file\\\" -o \\\"$file_base_name\\\" && start cmd /c \\\"${file_path}/${file_base_name} & pause\\\"\"\n       },\n       {\n            \"name\": \"Output\",       \n            \"cmd\": [\"g++\", \"-Wall\",\"${file}\", \"-o\", \"${file_path}/${file_base_name}\", \"&&\", \"start\",\"/D ${file_path}\",\"run.bat\",\"${file_base_name}.exe\",\"std.in\",\"std.out\"]\n       },\n    ]\n}\n```\n\nrun.bat:\n```cpp\n@echo off\n%1 <%2 >%3\nif \"%1\" == \"h\" goto begin\nmshta vbscript:createobject(\"wscript.shell\").run(\"\"\"%~nx0\"\" h\",0)(window.close)&&exit\n:begin\nREM\n```\n\n快捷键：\n```cpp\n[\n\t{\"keys\": [\"f9\"], \"command\": \"build\", \"args\": {\"variant\": \"Run\"}},\n\t{\"keys\": [\"f10\"], \"command\": \"build\", \"args\": {\"variant\": \"Output\"}}  \n]\n\n```\n\n至此，大功告成！！！快快来享受代码的乐趣吧！\n（终于把编辑器配成了自己理想的样子）\n# 文件头部注释\n\n简介：在文件头部自动写上一啪啦的模板代码\n\n背景：由于Acmer在每个cpp文件都要写上头文件,宏定义等一系列模板，这个时候就需要一个插件FileHeader了\n\n安装什么的就不多说了，网上都有，这里重点讲下配置\n\n1.修改author等信息\n设置-->首选项-->插件设置-->File Header-->settings-User(这里一定是user,别选默认)\n添加以下内容\n\n```cpp\n{\n    \"Default\": {\n        \"author\":\"Ding Jianlong\",\n        \"last_modified_by\":\"Ding Jianlong\",\n        \"email\":\"123@51015.cn\"\n    }\n}\n```\n\n2.文件自动添加头文件，宏定义等文件头部注释\n在\"C:\\Users\\BohongLi\\AppData\\Roaming\\Sublime Text\\Packages\\FileHeader\\template\\header\"下找到对应语言的tmpl(C++是C++.tmpl)(AppData得显示隐藏文件才能看到)\n比如我这里是C++.tmpl，我就在文件末尾加上我的板子即可，注意板子中不要有注释符号\"//\"，不然可能显示不出来。\n\n好像template\\body里也有个对应的C++.tmpl，这个应该用来贴文件头部那一啪啦好像更合适，不过下次再弄吧，12点半了，困了，困了\n","tags":["工具"]},{"title":"再战128","url":"/2021/09/05/再战128/","content":"经过一个暑假的集训，试试集训的效果\n看看当年折磨人的128\n再次写完需要多久呢？\n<!--more-->\n\n# 写麻了，写了87道，休息一下，等心情好再写(滑稽)\n\n# 时间表\n1 9.5晚 22道      --30min\n2 9.6早 18道      --150min\n3 9.6晚 8道       --180min\n4 9.7   5道       --60min\n5 9.7晚 14道      --180min\n6 9.8   17道      --180min\n# 一些离谱的错误\n1.没搞懂的三点一线\n2.if 短路原则\n3.1218 solve 输出超限\n4.ll 超时 改 int 100ms过\n# 1112 三点共线\n题意：给你平面上三个点的坐标，请判断三点是否共线。\n直接判断斜率k1==k2错了，应该把这个分式转换成乘积的形式，减少出错。\n**abs只适用于整形，double要用fabs**\n**但是目前不知道错在哪了。。。。。。。。**\n\n# 1078 字母三角形\n题意：输出形如\nABCDEDCBA\n ABCDCBA\n  ABCBA\n    ABA\n     A\n的字母三角形。\n代码写得挺好看的(嘿嘿,写的代码比之前好多了  思路很清晰\n```cpp\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff//10^9级别，不到2^32\ntypedef long long ll;\nconst ll maxn=2e5+11;\nvoid out1(ll n){\n    for(ll i=0;i<n;i++)  cout<<\" \";\n}\nvoid out2(ll n){\n    for(ll i='A';i<n;i++)  printf(\"%c\",i);\n    printf(\"%c\",n);\n    for(ll i=n-1;i>='A';i--)  printf(\"%c\",i);\n}\nint main(){\n    // ios::sync_with_stdio(false);\n    // cin.tie(0);\n    char c;ll step=1;\n    while(cin>>c){\n        if(c=='#')  break;\n        cout<<\"case \"<<step++<<\":\"<<endl;\n        for(ll i='A';i<=c;i++){\n            out1(i-'A');\n            out2(c-(i-'A'));\n            cout<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n# 1189 root\n题意：求方程 (x+a)/(x+b) = c的非负整数根，其中a,b,c都是非负整数。\n又寄了，烦死了。\nwa了还是得好好想想呐，不要急，锻炼自己找bug能力，积累debug经验。\n\n# 1223 Repeat One\n题目：求由最小的一个N，N个数码1组成的数能被M整除？ 比如M=3时，111能被3整除。M=2时，则不存在这样的N。\n一道有点意思的题目，但是放到数组里不合适吧，跟数组毛线关系都没有的，误导新手\n方法自己是想出来了的，但是超时了，自己应该自信点，毕竟很大的一个样例都对了，就不要怀疑是方法的问题\n555，又忍不住看了答案\n但是这道题自己想复杂了，n=(10*n+1)%x就行，**因为模x对结果无影响。**\n**tle了是因为常数开大了，每次循环都是maxn，改成n就过了。吸取教训！！！**\n\n# 1247 Robb's Problem\n题意：Robb想知道阶乘n!第m位数码是什么？\n居然有大数模拟是我没想到的，随便写下吧，不是很感兴趣,算了，挺恶心人的，懒得写了\n用java套大数就完事了\n\n# 1270 Unique Digit Number\n题意：数位不同的数是指所有数位上的数码都不一样的数，比如“123”三个数码1,2,3，都不一样，所以是数位不同的数；但是“1232”中有两个相同的数码2，所以不是。请写一个程序，计算第几个符合条件的数是什么？\n\n这是当时自己觉得最难的几道题目之一了吧，现在如今自己也能写出来了\n关键在于记录每个数用了哪些数字，以及把这个数的记录信息传到下一个数，这个时候就需要用到数位了。\n有一说一，用数位存数还是挺巧妙的，就是把一个数，看作一个数组。比如一个int数，有32位对吧，\n那么它就是一个长度为32的数组，只不过这个数组的每位只能存0和1，不过对这道题而言够了，只需要标记状态用0和1就够了\n这样子的话，无论是记录状态，还是传递状态，都很快速。\n\n# 1108 a+b\n题目：请计算a+b，但a和b是按不同的进制给出的。进制最小为2进制，最大为62进制，其中使用A-Z依次表示10到35，a-z表示36-61。请写出a+b的结果，结果按十进制输出。 输入 第一行是一个整数N，表示有多少个测试样例，以后每行是一个样例，每行是4个部分，分别为a的值，a的进制，b的值，b的进制。其中值都是用一个字符串表示，进制都是一个整数。4个部分之间用一个空格隔开，保证输入的合法，a、b和a+b的值都在-2^31到2^31-1之间。 输出 每行输出一个样例的结果。\n\n醉死，我先把字符串转化为数字，然后用sr.length()算字符串长度，但是我没有注意到，**将字符串转化的数字中，有0，那么再用sr.length()就会出错**，本地跑没有问题，一交上去就出错了。。。\n\n# 1378 blocks\n简单的DP，但无奈我PD蒟蒻，状态都写出来了，就差状态转移方程，居然没写出来。。\n","tags":["没想好标签的标签"]},{"title":"线段树+树状数组","url":"/2021/08/31/线段树-树状数组/","content":"\n线段树大C\n\n<!--more-->\n\n# 树状数组与线段树总结\n**时间复杂度**\n虽然它们都是nlogn，但是，你会发现，在查询时，树状数组最坏情况是logn（比如8个数，然后查询8），但是线段树是所有情况都是nlogn，稍慢于树状数组。\n\n**空间复杂度**\n\n树状数组完胜于线段树，线段树要开2倍到4倍内存（推荐4倍），但是树状数组一倍就够了。\n\n**适用范围**\n\n线段树之所以存在的理由是因为它能适用于很多方面，不仅仅是区间、单点的查询修改，还有标记等等，可以用于模拟、DP等等，而且空间经过离散化以后也可以相对压缩，所以适用范围线段树更加广一些。\n\n# 树状数组\n\n## 树状数组单点修改\n[模板](https://www.luogu.com.cn/problem/P3374)\n```cpp\n#include<bits/stdc++.h>\ntypedef long long ll;\nconst long long maxn=5e5+11;\nusing namespace std;\nll t[maxn],n;//树状数组空间开一倍就够了\nll lowbit(ll x){\n    return x & -x;\n}\nvoid add(ll x,ll val){\n    while(x<=n){\n        t[x]+=val;\n        x+=lowbit(x);\n    }\n}\nll getsum(ll x){\n    ll sum=0;\n    while(x>=1){\n        sum+=t[x];\n        x-=lowbit(x);\n    }\n    return sum;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll m;\n    cin>>n>>m;\n    for(ll i=1,val;i<=n;i++){\n        cin>>val;\n        add(i,val);\n    }\n    ll op,val,l,r;\n    while(m--){\n        cin>>op;\n        if(op==1){\n            cin>>l>>val;\n            add(l,val);\n        }\n        else if(op==2){\n            cin>>l>>r;\n            cout<<getsum(r)-getsum(l-1)<<endl;\n        }\n    }\n    return 0;\n}\n\n\n```\n\n\n# 线段树\n\n## 线段树单点修改\n[模板](https://www.luogu.com.cn/problem/P3374)\n```cpp\n//注意保证l<r及数据的合法性\n#include<bits/stdc++.h>\nusing namespace std;\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\ntypedef long long ll;\nconst long long maxn=5e5+11;\nll t[maxn<<2],ar[maxn]; //线段树得开四倍\nvoid push_up(ll now){\n    t[now]=t[now<<1]+t[now<<1|1];\n}\nvoid build(ll l,ll r,ll now){\n    if(l==r){\n        t[now]=ar[l];\n        return ;\n    }\n    ll m=l+((r-l)>>1);//这个操作挺牛逼的,不然我只会写m=(l+r)/2...\n    build(lson);build(rson);\n    push_up(now);\n}\n\nvoid add(ll x,ll val,ll l,ll r,ll now){\n    t[now]+=val;\n    if(l==r)  return ;\n    ll m=l+((r-l)>>1);\n    if(x<=m)  add(x,val,lson);\n    else  add(x,val,rson);\n}\nll getsum(ll L,ll R,ll l,ll r,ll now){\n    if(L<=l && r<=R){\n        return t[now];\n    }\n    ll m=l+((r-l)>>1);\n    ll sum=0;\n    if(L<=m)  sum+=getsum(L,R,lson);\n    if(R>m)  sum+=getsum(L,R,rson);\n    return sum;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n,m;\n    cin>>n>>m;\n    for(ll i=1;i<=n;i++){\n        cin>>ar[i];\n    }\n    build(1,n,1);\n    ll op,x,val,r;\n    while(m--){\n        cin>>op;\n        if(op==1){\n            cin>>x>>val;\n            add(x,val,1,n,1);\n        }\n        else if(op==2){\n            cin>>x>>r;\n            cout<<getsum(x,r,1,n,1)<<endl;\n        }\n    }\n    return 0;\n}\n\n```\n## 线段树区间修改\n[模板](https://www.luogu.com.cn/problem/P3372)\n```cpp\n//注意保证l<r及数据的合法性\n#include<bits/stdc++.h>\nusing namespace std;\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\ntypedef long long ll;\nconst long long maxn=5e5+11;\nll t[maxn<<2],ar[maxn],lazy[maxn<<2];//线段树得开四倍\nvoid push_up(ll now){\n    t[now]=t[now<<1]+t[now<<1|1];\n}\nvoid push_down(ll l,ll r,ll now){\n    ll m=l+((r-l)>>1);\n    if(lazy[now]){\n        t[now<<1]+=lazy[now]*(m-l+1),lazy[now<<1]+=lazy[now];\n        t[now<<1|1]+=lazy[now]*(r-m),lazy[now<<1|1]+=lazy[now];\n        lazy[now]=0;\n    }\n}\nvoid build(ll l,ll r,ll now){\n    if(l==r){\n        t[now]=ar[l];\n        return ;\n    }\n    ll m=l+((r-l)>>1);//这个操作挺牛逼的,不然我只会写m=(l+r)/2...\n    build(lson);build(rson);\n    push_up(now);\n}\nvoid add(ll L,ll R,ll val,ll l,ll r,ll now){\n    if(L <= l && r <= R){//因为输入数据的L,R可能超过最大范围\n        t[now]+=(r-l+1)*val,lazy[now]+=val;\n        return;\n    }\n    ll m=l+((r-l)>>1);\n    push_down(l,r,now);\n    if(L<=m) add(L,R,val,lson);\n    if(R>m) add(L,R,val,rson);\n    push_up(now);\n}\nll getsum(ll L,ll R,ll l,ll r,ll now){\n    if (L<=l && r<=R)  return t[now];\n    ll m=l+((r-l)>>1);\n    push_down(l,r,now);\n    ll sum=0;\n    if(L<=m)  sum=getsum(L,R,lson);\n    if(R>m)  sum+=getsum(L,R,rson);\n    return sum;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n,m;\n    cin>>n>>m;\n    for(ll i=1;i<=n;i++){\n        cin>>ar[i];\n    }\n    build(1,n,1);\n    ll op,x,val,r;\n    while(m--){\n        cin>>op;\n        if(op==1){\n            cin>>x>>r>>val;\n            add(x,r,val,1,n,1);\n        }\n        else if(op==2){\n            cin>>x>>r;\n            cout<<getsum(x,r,1,n,1)<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n## 线段树扫描线\n[模板](https://www.luogu.com.cn/problem/P5490)\n```cpp\n//没有下放操作，在cnt=1时不会错，cnt=2时会错,即如果求矩形面积的并不会错，求至少覆盖两次的会出错\n//线段树每个点代表一个区间，不能用每个点代表一个点\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define Debug(x) cout<<#x<<\":\"<<x<<endl;\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\ntypedef long long ll;\nconst ll maxn=4e5+11;\nstruct Line{\n    ll x1,x2,y,w;\n    bool operator < (const Line& b)  const{\n        return y<b.y;\n    }\n}line[maxn];\nll t[maxn<<2],cnt[maxn<<2],x[maxn],step;\nvoid push_up(ll l,ll r,ll now){\n    if(cnt[now])  t[now]=x[r+1]-x[l];\n    else  t[now]=t[now<<1]+t[now<<1|1];\n}\nvoid update(ll L,ll R,ll val,ll l,ll r,ll now){\n    if(L<=l && r<=R){\n        cnt[now]+=val;\n        push_up(l,r,now);\n        return ;\n    }\n    ll m=l+((r-l)>>1);\n    if(L<=m)  update(L,R,val,lson);\n    if(R>m)  update(L,R,val,rson);\n    push_up(l,r,now);\n}\nll pos(ll xi){\n    return lower_bound(x+1,x+1+step,xi)-x;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;cin>>n;\n    for(ll i=1,x1,y1,x2,y2;i<=n;i++){\n        cin>>x1>>y1>>x2>>y2;\n        line[(i<<1)-1].x1=x1,line[(i<<1)-1].x2=x2,line[(i<<1)-1].y=y1,line[(i<<1)-1].w=1;\n        line[i<<1].x1=x1,line[i<<1].x2=x2,line[i<<1].y=y2,line[i<<1].w=-1;\n        x[(i<<1)-1]=x1,x[i<<1]=x2;\n    }\n    sort(line+1,line+1+2*n);\n    sort(x+1,x+1+2*n);\n    step=unique(x+1,x+1+2*n)-(x+1);\n    ll ans=0;\n    for(ll i=1;i<=2*n-1;i++){\n        update(pos(line[i].x1),pos(line[i].x2)-1,line[i].w,1,step-1,1);\n        ans+=t[1]*(line[i+1].y-line[i].y);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n# 4⭐树状数组统计ai之前比ai小的数个数\n题意：给一个长度为n<5e4的数列，每个数编号从1到n，且无重复。一个四元组(a,b,c,d)，要求a<b<c<d 且 Aa<Ab && Ac<Ad,问数列中这样的四元组有多少个。\n\n思路：关键在于如何统计数列中在ai之前且比ai小的数有多少个。用树状数组统计，代码如下：\nfor(ll i=1;i<=n;i++)  re[i]=sum(ar[i]),add(ar[i],1);\n知道这点后，对于四元组中每个b，其四元组个数为(b之前小于b的个数)*(b之后的(c,d)对数)，对于(c,d)对数统计，即倒过来再扫一遍即可。\n\n```cpp\n\n#include<iostream>\n#include<cstring>\ntypedef long long ll;\nconst long long maxn=5e4+11;\nusing namespace std;\nll t[maxn],ar[maxn],markl[maxn],markr[maxn],n;//树状数组空间开一倍就够了\nll lowbit(ll x){\n    return x & -x;\n}\nvoid add(ll x,ll val){\n    while(x<=n){\n        t[x]+=val;\n        x+=lowbit(x);\n    }\n}\nll getsum(ll x){\n    ll sum=0;\n    while(x>=1){\n        sum+=t[x];\n        x-=lowbit(x);\n    }\n    return sum;\n}\nvoid solve(){\n    memset(t,0,sizeof(t));\n    for(ll i=1;i<=n;i++){\n        markl[i]=getsum(ar[i]);\n        add(ar[i],1);\n    }\n    memset(t,0,sizeof(t));\n    memset(markr,0,sizeof(markr));\n    for(ll i=n;i>=1;i--){\n        markr[i]=n-i-getsum(ar[i])+markr[i+1];\n        add(ar[i],1);\n    }\n    ll ans=0;\n    for(ll i=1;i<=n-1;i++){\n        ans+=markl[i]*markr[i+1];\n    }\n    cout<<ans<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll t;cin>>t;\n    while(t--){\n        cin>>n;\n        for(ll i=1;i<=n;i++)  cin>>ar[i];\n        solve();\n    }\n    return 0;\n}\n\n```\n\n\n# 线段树基本运用（有另类巧妙做法）\n**题意** 有 t 组数据，每组有 n 张(1<=n<=1e4)覆盖了 区间 [li,ri] 的海报(1<=i<=n,1<=li<=ri<=1e7)，海报会由于张贴顺序先后而被覆盖 问还有多少张海报能够看得见\n[优质题解](https://blog.csdn.net/weixin_44077863/article/details/98037868)\n\n<details>\n  <summary>点击查看代码</summary>\n  <pre><code>  \n\n```cpp\n//两种做法\n//dfs做法\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn=1e5+11;\nll li[maxn],ri[maxn],vis[maxn],ans;\nvoid dfs(ll l,ll r,ll x){\n    if(x==0)  return ;\n    if(l<=ri[x] && li[x]<=r){\n        if(!vis[x]){\n            vis[x]=1;ans++;\n        }\n        if(l<li[x])  dfs(l,li[x]-1,x-1);\n        if(r>ri[x])  dfs(ri[x]+1,r,x-1);\n    }\n    else  dfs(l,r,x-1);\n}\nvoid init(){\n    memset(vis,0,sizeof(vis));\n    ans=0;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll t;cin>>t;\n    while(t--){\n        init();\n        ll n;cin>>n;\n        for(ll i=1;i<=n;i++)  cin>>li[i]>>ri[i];\n        dfs(1,1e7,n);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n\n//线段树做法\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\nusing namespace std;\n#define Debug(x) cout<<#x<<\":\"<<x<<endl;\ntypedef long long ll;\nconst ll maxn=3e4+11;\nll t[maxn<<2],vis[maxn<<2],x[maxn<<2],a[maxn<<2],b[maxn<<2],ans,step;\nvoid push_down(ll now){\n    if(t[now]){\n        t[now<<1]=t[now<<1|1]=t[now];\n        t[now]=0;\n    }\n}\nvoid update(ll L,ll R,ll val,ll l,ll r,ll now){\n    if(L<=l && r<=R){\n        t[now]=val;return ;\n    }\n    push_down(now);\n    ll m=l+((r-l)>>1);\n    if(L<=m) update(L,R,val,lson);\n    if(R>m) update(L,R,val,rson);\n}\nvoid query(ll l,ll r,ll now){\n    if(t[now] && !vis[t[now]]){\n        vis[t[now]]=1;ans++;\n        return ;\n    }\n    if(l==r)  return ;\n    push_down(now);\n    ll m=l+((r-l)>>1);\n    query(lson);query(rson);\n}\nll pos(ll xi){\n    return lower_bound(x+1,x+1+step,xi)-x;\n}\nvoid init(){\n    memset(vis,0,sizeof(vis));\n    memset(t,0,sizeof(t));\n}\nint main(){\n    ll ta;cin>>ta;\n    while(ta--){\n        init();\n        ll n;step=1;cin>>n;\n        for(ll i=1;i<=n;i++){\n            cin>>a[i]>>b[i];\n            if(b[i]-a[i]>1)  x[step++]=a[i]+1;\n            x[step++]=a[i];x[step++]=b[i];\n        }\n        sort(x+1,x+step);\n        step=unique(x+1,x+step)-(x+1);\n        for(ll i=1;i<=n;i++){\n            update(pos(a[i]),pos(b[i]),i,1,step,1);\n        }\n        ans=0;query(1,step,1);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n  </code></pre>\n</details>\n\n# 线段树基本运用（有另类巧妙做法）\n**题意**\nn个点，m个操作(1<=n,m<=5e4)，m行中每行一个字符c表示操作类型，一个整型数x表示第x个点\nD x 表示去掉第x点，Q x表示需输出含 x 的最大连续区间的长度，R x表示还原最后去掉的点\n\n[优质题解](https://blog.csdn.net/weixin_44077863/article/details/99681125)\n\n# 线段树灵活运用(1700)\n**题意**\nt 组数据(t<=10)，每组第一行一个 n 表示 n 个员工(n<=5e4)，接下来 n-1 行，每行两个整数 u,v 表示 v 是 u 的上司\n然后一行 m 表示有 m 个操作(m<=5e4) ， 接下来 m 行 由一个字符 和 整型数构成 ，表示不同操作\nC x 表示 输出 第 x 个员工的工作号 \nT x y 表示 将 第 x 个员工的工作号变为 y (x<=n，0<=y<=1e9)\n规定，改变工作时，被改变员工的下属一同变为 y\n\n[优质题解](https://blog.csdn.net/weixin_44077863/article/details/100050457)\n**注意用线段树求某点对应区间时，只需要在dfs序时，记录其区间左端点和右端点即可，没必要再拉个深度d数组，再二分找**\n\n# 线段树灵活运用-不确定区间\n题意：有n<5e4个花瓶，编号0~n-1，有m<5e4次操作，操作1：从a开始放f个花瓶，输出花瓶放置的第一个位置和最后一个位置，操作2：拿掉a~b之间的花瓶，输出拿掉的花瓶的数量\n\n思路：由于这题是从a开始放f个花瓶，那么与以往线段树不同的一点是，这个区间的右端点是不确定的，得我们自己确定这个区间的右端点。**虽然最容易想到的是在线段树里模拟放置花瓶，但是这肯定是不行的。第一，线段树的一般用法不是这么用的，第二，模拟的细节巨多，耗时，炸心，不可能写出来。**那我们的方法就是通过二分查找出这个区间的右端点即可，还有一个点就是还需要找到放置花瓶的起始位置和最后一个位置，剩下的就是基础线段树操作。这道题还是需要线段树较扎实的功底的。\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-17 15:02:14\n*/\n#include<iostream>\n#include<cstring>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=5e4+11;\nll t[maxn<<2],lazy[maxn<<2],beg,en,ans;\n//编号0~N-1\nvoid push_up(ll now){\n    t[now]=t[now<<1]+t[now<<1|1];\n}\nvoid push_down(ll l,ll r,ll now){\n    if(lazy[now]>=0){\n        ll m=l+((r-l)>>1);\n        t[now<<1]=(m-l+1)*lazy[now];t[now<<1|1]=(r-m)*lazy[now];\n        lazy[now<<1]=lazy[now<<1|1]=lazy[now];\n        lazy[now]=-1;\n    }\n}\nvoid build(){\n    memset(t,0,sizeof(t));\n    memset(lazy,-1,sizeof(lazy));\n}\nll get_sum(ll L,ll R,ll l,ll r,ll now){\n    if(L<=l && r<=R){\n        return t[now];\n    }\n    push_down(l,r,now);\n    ll m=l+((r-l)>>1);\n    ll sum=0;\n    if(L<=m)  sum+=get_sum(L,R,lson);\n    if(R>m)  sum+=get_sum(L,R,rson);\n    return sum;\n}\nvoid add(ll L,ll R,ll l,ll r,ll now){\n    if(L<=l && r<=R){\n        t[now]=r-l+1;lazy[now]=1;\n        return ;\n    }\n    push_down(l,r,now);\n    ll m=l+((r-l)>>1);\n    if(L<=m)  add(L,R,lson);\n    if(R>m)  add(L,R,rson);\n    push_up(now);\n}\nvoid dle(ll L,ll R,ll l,ll r,ll now){\n    if(L<=l && r<=R){\n        ans+=t[now];t[now]=0;lazy[now]=0;\n        return ;\n    }\n    push_down(l,r,now);\n    ll m=l+((r-l)>>1);\n    if(L<=m)  dle(L,R,lson);\n    if(R>m)  dle(L,R,rson);\n    push_up(now);\n}\nvoid found_b(ll L,ll R,ll l,ll r,ll now){\n    if(t[now]==r-l+1)  return ;\n    if(beg!=-1)  return ;\n    if(l==r && t[now]==0){\n        beg=l;return ;\n    }\n    push_down(l,r,now);\n    ll m=l+((r-l)>>1);\n    if(L<=m)  found_b(L,R,lson);\n    if(R>m)  found_b(L,R,rson);\n}\nvoid found_e(ll L,ll R,ll l,ll r,ll now){\n    if(t[now]==r-l+1)  return ;\n    if(en!=-1)  return ;\n    if(l==r && t[now]==0){\n        en=l;return ;\n    }\n    push_down(l,r,now);\n    ll m=l+((r-l)>>1);\n    if(R>m)  found_e(L,R,rson);\n    if(L<=m)  found_e(L,R,lson);\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ta;cin>>ta;\n    while(ta--){\n        ll n,m;cin>>n>>m;\n        build();\n        for(ll i=1,o,a,f;i<=m;i++){\n            cin>>o>>a>>f;\n            if(o==1){\n                ll nn=get_sum(a,n-1,0,n-1,1);\n                beg=-1;en=-1;\n                found_b(a,n-1,0,n-1,1);found_e(a,n-1,0,n-1,1);\n                if(nn==n-a){\n                    cout<<\"Can not put any one.\"<<endl;\n                    continue;\n                }\n                if(nn+f>=n-a){\n                    add(a,n-1,0,n-1,1);\n                    cout<<beg<<\" \"<<en<<endl;continue;\n                }\n                ll l=a,r=n-1;\n                while(l<r){\n                    ll mid=(r+l)>>1;\n                    if(get_sum(a,mid,0,n-1,1)+f<=mid-a+1)  r=mid;\n                    else  l=mid+1;\n                }\n                add(a,l,0,n-1,1);\n                cout<<beg<<\" \"<<l<<endl;continue;\n            }\n            else{\n                ans=0;\n                dle(a,f,0,n-1,1);\n                cout<<ans<<endl;continue;\n            }\n            \n        }\n        cout<<endl;\n    }\n    return 0;\n}\n\n\n```\n\n# 线段树-找最近小\nThe 2021 ICPC Asia Regionals Online Contest  A Busiest Computing Nodes\n题意：有k<1e5个工厂，从0~k-1编号，有n个任务，从0~n-1编号，每个任务有一个到达时间和一个处理时间。每个任务到达时，若其任务编号为i，则先从第i%k个工厂开始往后找,i+1%k,i+2%k.....一直找到i-1%k，如果所有工厂都不空闲，则此任务被丢弃，问处理任务最多的工厂是哪些。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n思路：即找最近小的t，满足arrival_time（记为ta） < t,那么因为这个是最近小，距离是第一优先级，就不能用单调队列那些，因为不是按t排序的。这里就要用到二分查找。查找分为两个区间，一个是[i%k,n-1],另一个是[0,i-1%k]，前者记为a区间，后者记为b区间。先找到a区间的最小值，如果最小值(记为minn)都>ta，则找b区间。否则“先”在a区间的左半区间找，若minn>ta，则找a的右半区间找。即先找每个区间的左区间，左区间没有再找右区间即可。是一个二分的思想。用线段树维护区间最小值即可。我一开始也没想到二分还能这么用，因为我看这道题t不是单调的，但是现在发现距离是单调的，所以**查找最近小还是可以用二分**。\n\n  </code></pre>\n</details>\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-20 12:29:16\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e5+11;\nll t[maxn<<2],cnt[maxn],maxx;\nvector<ll> v;\nvoid push_up(ll now){\n    t[now]=min(t[now<<1],t[now<<1|1]);\n}\nvoid update(ll L,ll val,ll l,ll r,ll now){\n    if(L==l && L==r){t[now]=val;return ;}\n    ll m=l+((r-l)>>1);\n    if(L<=m)  update(L,val,lson);\n    else  update(L,val,rson);\n    push_up(now);\n}\nll found(ll L,ll R,ll val,ll l,ll r,ll now){\n    if(val<t[now])  return -1;\n    if(l==r && t[now]<=val){\n        return l;\n    }  \n    if(l==r)  return -1;\n    ll m=l+((r-l)>>1);\n    ll flag=-1;\n    if(L<=m)  flag=found(L,R,val,lson);\n    if(flag==-1){\n        if(R>m)  return found(L,R,val,rson);\n    }\n    return flag;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll k,n;cin>>k>>n;\n    for(ll i=0,ta,tc;i<n;i++){\n        cin>>ta>>tc;\n        ll pos=i%k;\n        ll flag=found(pos,k-1,ta,0,k-1,1);\n        if(flag==-1){\n            if(pos==0)  continue;\n            ll flagg=found(0,pos-1,ta,0,k-1,1);\n            if(flagg==-1)  continue;\n            flag=flagg;\n        }\n        update(flag,ta+tc,0,k-1,1);\n        cnt[flag]++;\n        if(cnt[flag]>maxx){\n            maxx=cnt[flag];v.clear();v.push_back(flag);\n        }\n        else if(cnt[flag]==maxx)  v.push_back(flag);\n    }\n    sort(v.begin(),v.end());\n    for(auto i=v.begin();i!=v.end();i++){\n        if(i==v.end()-1)  cout<<*i;\n        else  cout<<*i<<\" \";\n    }\n    return 0;\n}\n\n```\n\n# Segment Tree beats 维护一个数列\n题意\n\n![](/uploads/ACM比赛划水记录/2021-09-27-20-22-39.png)\n\n![](/uploads/ACM比赛划水记录/2021-09-27-20-22-49.png)\n\n这里对于100以内的25个质数的维护，可以状态压缩，即用一个int的一位二进制表示改质数是否存在。也就是再拉个线段树维护25个质数。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x)  cout<<#x<<\": \"<<x<<endl;\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\ntypedef long long ll;\nconst ll maxn=1e5+11;\nconst ll mo=998244353;\nll t[maxn<<2],rr[maxn<<2],x[maxn],lazy[maxn<<2],ar[111];\nll tmp;\nll is(ll x){\n    for(ll i=2;i*i<=x;i++)  if(x%i==0)  return 0;\n    return 1;\n}\nvoid init(){\n    tmp=0;\n    for(ll i=2;i<=100;i++){\n        if(is(i))  ar[tmp++]=i;\n    }\n}\nll fy(ll x){//计算x的欧拉值\n    ll ans=x;\n    for(ll i=0;i<25;i++){\n        if(x%ar[i]==0){\n            ans=ans*(ar[i]-1)/ar[i];\n        }\n    }\n    return ans;\n}\nll wei(ll x){\n    ll ans=0;\n    for(ll i=0;i<25;i++){\n        if(x%ar[i]==0){\n            ans=ans|(1<<i);\n        }\n    }\n    return ans;\n}\nvoid push_up(ll now){\n    t[now]=(t[now<<1]+t[now<<1|1])%mo;\n    rr[now]=rr[now<<1]&rr[now<<1|1];\n}\nvoid push_down(ll l,ll r,ll now){\n    if(lazy[now]>1){\n        t[now<<1]=t[now<<1]*lazy[now]%mo;\n        lazy[now<<1]=lazy[now<<1]*lazy[now]%mo;\n        t[now<<1|1]=t[now<<1|1]*lazy[now]%mo;\n        lazy[now<<1|1]=lazy[now<<1|1]*lazy[now]%mo;\n        lazy[now]=1;\n    }\n}\nvoid build(ll l,ll r,ll now){\n    lazy[now]=1;\n    if(l==r){\n        t[now]=fy(x[l]);rr[now]=wei(x[l]);\n        return ;\n    }\n    ll m=l+((r-l)>>1);\n    build(lson);build(rson);\n    push_up(now);\n}\nvoid update(ll L,ll R,ll w,ll val,ll l,ll r,ll now){\n    if(L<=l && r<=R && (rr[now]&val)==val){\n        t[now]=t[now]*w%mo;lazy[now]=lazy[now]*w%mo;\n        return ;\n    }\n    if(l==r){\n        t[now]=t[now]*w;\n        for(ll i=0;i<25;i++){\n            if(((rr[now]>>i)&1)==0 && ((val>>i)&1)==1){\n                t[now]=t[now]*(ar[i]-1)/ar[i];\n            }\n        }\n        t[now]=t[now]%mo;\n        rr[now]=rr[now]|val;  \n        return ;\n    }\n    ll m=l+((r-l)>>1);\n    push_down(l,r,now);\n    if(L<=m)  update(L,R,w,val,lson);\n    if(R>m)  update(L,R,w,val,rson);\n    push_up(now);\n}\nll getsum(ll L,ll R,ll l,ll r,ll now){\n    if(L<=l && r<=R)  return t[now];\n    ll m=l+((r-l)>>1);\n    push_down(l,r,now);\n    ll sum=0;\n    if(L<=m)  sum=getsum(L,R,lson)%mo;\n    if(R>m)  sum=(sum+getsum(L,R,rson))%mo;\n    return sum;\n}\nint main(){\n    init();\n    ll n,m;cin>>n>>m;\n    for(ll i=1;i<=n;i++)  cin>>x[i];\n    build(1,n,1);\n    for(ll i=1;i<=m;i++){\n        ll op,l,r,w;\n        cin>>op;\n        if(op==0){\n            cin>>l>>r>>w;\n            if(w==1)  continue;\n            update(l,r,w,wei(w),1,n,1);\n        }\n        if(op==1){\n            cin>>l>>r;\n            cout<<getsum(l,r,1,n,1)<<endl;\n        }\n    }\n    return 0;\n}\n\n```\n\n\n\n","tags":["数据结构"]},{"title":"2021XTU程设考试","url":"/2021/08/31/2021XTU程设考试/","content":"\n好菜啊，就做了一道题，挂科了555\n赶忙来补题\n\n<!--more-->\n\n# xtu 1385 面积\n正方形边长为1,E是对角线BD上一点，F是边AB上一点，已知|DE|=a/b|DB|,|BF|=c/d|AB|，求△CEF的面积。\n\n思路:推公式,注意为负数的情况\n\n```cpp\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        int a,b,c,d;\n        scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n        int m=b*d-a*c-a*d;\n        int n=2*b*d;\n        if(m==0){\n            printf(\"0\\n\");\n            continue;\n        }  \n        if(m<0)  m=abs(m);\n        int k=__gcd(m,n);\n        m/=k,n/=k;\n        printf(\"%d/%d\\n\",m,n);\n    }\n    return 0;\n}\n```\n\n#  xtu 1386\t彩球\n有n个球，标号为1∼n，第i个球有的颜色为ci。你需要选择3个不同颜色的球，问有多少种不同的选择方案？\n\n思路:先hash统计各个颜色气球数量(可以map,unordered_map,unordered_map应该不会超时,map不知道)\n然后因为直接数三个不同色的很困难,这里就得用到间接法,但是谢大认为这是小学三年级知识,其实我们大部分人都没想到.\n就是用从n个球中选出3个球的方案数(即组合数C n 选3) 减去 三球同色 减去 两球同色,即为三球不同色的方案数,复杂度是O(n)的,可以接受\n\n坑点:64位如果是scanf输入记得用__int64,不然会wa,用cin的可以不用管\n\n```cpp\n#include<iostream>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\n#define mo 20011\n#define maxn 10000\nll re[mo+11];\ninline ll hash1(ll n){\n    ll x=n%mo;\n    if(re[x]==INF)  {re[x]=n;return x;}\n    else{\n        ll i=0;\n        while(re[(x+i)%mo]!=INF){\n            if(re[(x+i)%mo]!=n) i++;\n            else  return (x+i)%mo;\n        }  \n        re[(x+i)%mo]=n;\n        return (x+i)%mo;\n    }\n}\nvoid init(){//哈希表初始化\n    for(ll i=0;i<mo;i++)  re[i]=INF;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll t;\n    cin>>t;\n    while(t--){\n        init();\n        ll co[mo+11]={0};\n        ll ar[mo+11]={0};\n        ll n;\n        cin>>n;\n        for(ll i=1;i<=n;i++){\n            ll t;cin>>t;\n            co[hash1(t)]++;\n        }\n        ll step=0;\n        for(ll i=0;i<mo;i++){\n            if(co[i]!=0){\n                ar[++step]=co[i];\n            }\n        }\n        ll ans=n*(n-1)*(n-2)/6;\n        for(ll i=1;i<=step;i++){\n            if(ar[i]>=3)  ans=ans-ar[i]*(ar[i]-1)*(ar[i]-2)/6;\n            if(ar[i]>=2)  ans=ans-ar[i]*(ar[i]-1)/2*(n-ar[i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n# xtu 1387\t完全区间\n序列X由线性产生式 xn=axn−1+bxn−2,x0=x1=1 产生，\n序列Y由线性产生式 yn=cyn−1+dyn−2,y0=y1=1 产生，\n集合Z={x+y∣x∈X,y∈Y}。\n现有区间[L,R]，求最长的子区间[l,r],满足L≤l≤r≤R,∀z∈[l,r],z∈Z。\n\n思路：题目看似数据量很大，到10^9,我也是一开始被吓到了\n  其实不然，仔细分析\n  因为斐波那契数列增长很快，约为2的x次方，指数级别\n  所以x中最多到差不多50项，就会超出1e9次方，即x中最多50个元素\n  同理，y中最多也只有50个，那么z中最多就只有50*50个\n  可以枚举产生Z  复杂度可以接受\n  最后再在L~R区间内遍历一遍,找出最长子区间即可\n\n坑点:最好用64位,不然容易爆int,很多人re了我不知道什么原因\n\n```cpp\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e9;\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\tll t;\n\tcin>>t;\n\twhile(t--){\n\t\tll a,b,c,d,l,r;\n\t\tll x[55]={1,1,1},y[55]={1,1,1};\n\t\tll re[2555],step=1;\n\t\tcin>>a>>b>>c>>d>>l>>r;\n\t\tll l1=2,l2=2;\n\t\tfor(ll i=3;i<55;i++){\n\t\t\tx[i]=a*x[i-1]+b*x[i-2];\n\t\t\tl1++;\n\t\t\tif(x[i]<=0 || x[i]>=1e9)  break;\n\t\t}\n\t\tfor(ll i=3;i<55;i++){\n\t\t\ty[i]=c*y[i-1]+d*y[i-2];\n\t\t\tl2++;\n\t\t\tif(y[i]<=0 || y[i]>=1e9)  break;\n\t\t}\n\t\tfor(ll i=1;i<l1;i++){\n\t\t\tfor(ll j=1;j<l2;j++){\n\t\t\t\tif(l<=x[i]+y[j] && x[i]+y[j]<=r){\n\t\t\t\t\tre[step++]=x[i]+y[j];\n\t\t\t\t\t//Debug(re[step-1]);\n\t\t\t\t}  \n\t\t\t}\n\t\t}\n\t\tsort(re+1,re+step);\n\t\tstep=unique(re+1,re+step)-(re+1);\n\t\tif(step==0)  cout<<0<<endl;\n\t\telse{\n\t\t\tll length=1,maxl=1;\n\t\t\tfor(ll i=2;i<=step;i++){\n\t\t\t\t//Debug(re[i]);\n\t\t\t\tif(re[i]==re[i-1]+1){\n\t\t\t\t\tlength++;\n\t\t\t\t\tif(length>maxl)  maxl=length;\n\t\t\t\t}  \n\t\t\t\telse  length=1;\n\t\t\t}\n\t\t\tcout<<maxl<<endl;\n\t\t}\n\t}\n    return 0;\n}\n```\n\n# xtu 1388\t积木\n积木块都是相同的立方体，一共有n列积木堆，这n列积木排成一排，每堆上是ai个积木堆叠起来，并且保证从左到右，每列的积木数是非递减的。\n\n现在你还有k个积木块，请把这k个积木块放到积木上（可以只用部分积木块，但不能堆新的列）。你想的到一个连续的积木列，并使得这些积木列具有相同的高度。\n\n请问你能得到这样的积木列的最大宽度？\n \n 思路:\n 最长区间问题,容易想到尺取,要用尺取,序列就得满足单调性,这题随着区间长度递增,k值是递增的,满足单调性.\n 具体来说就是用两个指针,一个右指针指向区间右边端点,一个左指针指向区间左边端点,用sum值记录这个区间内满足连续积木列所需的木块数,当sum<=k时,右指针右移,区间长度+1,当sum>k时,左指针右移,区间长度-1.记录下满足条件的最大长度\n\n小提示:\"巨大的输入量，请使用stdio.h头文件，并使用C风格的输入\",这句话在xtu oj经常有,但其实关了同步,用cin也不是很慢.像这道题就是.\n```cpp\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef __int64 ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=10000+11;\nll ar[maxn];\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll t;\n    cin>>t;\n    while(t--){\n        ll n,k;\n        cin>>n>>k;\n        for(ll i=1;i<=n;i++)  cin>>ar[i];\n        ll l=1,r=1,length,maxl,k1=0;\n        for(ll r=1;r<=n;r++){\n            if(r==1){\n                length=1;\n                maxl=1;\n            }  \n            else{\n                if(ar[r]!=ar[r-1])  k1=k1+(r-l)*(ar[r]-ar[r-1]);\n                length++;\n                while(k1>k){\n                    k1=k1-(ar[r]-ar[l]);\n                    length--;\n                    l++;\n                }\n                if(length>maxl)  maxl=length;\n            }\n        }\n        cout<<maxl<<endl;\n    }\n    return 0;\n}\n```\n\n另一个思路:最长区间长度,由关键词最长,也容易想到二分,就是二分枚举最大宽度,对于每个宽度check下是否符合要求\n\n# xtu 1389\t二叉查找树\nn个元素，依次插入一颗初始为空的二叉查找树。对于第i个元素，其所在二叉查找书的左右子树深度差的绝对值为di，求max{di}。\n\n板子题,直接套数据结构书上的模板就行了,思路没啥好讲的\n\n```cpp\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ntypedef struct Node * BST;\nstruct Node{\n    int num;\n    BST left;\n    BST right;\n};\nint GetHeight(BST a);\nBST Insert(BST a,int b);\nBST Free1(BST a);\nint max_num;\nint main(){\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        max_num=0;\n        int n;\n        scanf(\"%d\",&n);\n        BST root;\n        root=NULL;\n        for(int i=0;i<n;i++){\n            int b;\n            scanf(\"%d\",&b);\n            root=Insert(root,b);\n        }  \n        GetHeight(root);\n        printf(\"%d\\n\",max_num);\n        Free1(root);//free大大减少OJ上的空间\n    }\n    return 0;\n}\nint GetHeight(BST a){\n    if(!a)  return 0;\n    int d,max_2,hl,hr;\n    hl=GetHeight(a->left);\n    hr=GetHeight(a->right);\n    max_2=hl>hr?hl:hr;\n    d=abs(hr-hl);\n    if(d>max_num)  max_num=d;\n    return (max_2+1);\n}\nBST Insert(BST a,int b){//递归插入相对耗时较长\n    if(!a){//为空树时也可以插入\n        a=(BST)malloc(sizeof(struct Node));\n        a->num=b;\n        a->left=a->right=NULL;\n    }\n    else{\n        if(b>a->num)  a->right=Insert(a->right,b);\n        else if(b<a->num)  a->left=Insert(a->left,b);\n        //b==a->num情况不考虑\n    }\n    return a;\n}\nBST Free1(BST a){\n    if(a){//若未考虑非空情况，会导致出错！\n        if(a->left==NULL && a->right==NULL){\n            free(a);\n            a=NULL;\n            return NULL;\n        }  \n        a->left=Free1(a->left);\n        a->right=Free1(a->right);\n        free(a);\n        a=NULL;\n        return NULL;\n    }\n    else  return NULL;\n}\n```\n# xtu 1390\t字母计数\n为了压缩一个只含小写英文字母的字符串，我们使用下面的方式表示它\n\n任一字母c是表达式\n任一字母c后接一个整数n也是一个表达式，表示把字母c重复n次，n是一个没有前导零的10进制整数，且 n≥2。\n如果s1,s2是表达式，那么s1s2也是表达式。\nS是一个表达式，那么(S)n也是表达式，表示将S这个表达式表示的字符串重复n次，n是一个没有前导零的10进制整数，且 n≥2。\n比如表达式 ((a2b)2b)2a 表示字符串aabaabbaabaabba。\n\n现在给你一个表达式，请统计一下其中各个字符出现的次数。\n\n思路:很典型的递归处理,因为每次处理的字符串规则都是一样的,对于括号内的字符串,可以将它看成一个新字符串来递归处理.\n\n坑点:oj的64位是真的坑,不小心用了个long long来用scanf转化输出字符就错了,建议大家在xtu oj上要么别用long long,要么用__int64,要么就不用scanf.\n\n代码:\n\n```cpp\n/*** \n * @Practice Win\n * @打h_1,h_2\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nll cnt[222];\nstring sr;\nll number(ll l,ll r){//将数字字符串转化为整数\n    ll ans=0;\n    for(ll i=l;i<r;i++){\n        ans=ans*10+sr[i]-'0';\n    }\n    return ans;\n}\nvoid solve(ll l,ll r,ll power){//递归处理，l是串起点，r是终点，power是串乘以的倍数\n                            //关于power，因为括号后面可以接数字，表示几倍，所有需要power记录\n    for(ll i=l;i<r;i++){\n        if(sr[i]=='('){//如果是括号\n            ll t=1,p=i+1;\n            for(;p<r;p++){//找到这个括号对应的右括号位置\n                if(t==0)  break;\n                if(sr[p]=='(')  t++;\n                if(sr[p]==')')  t--;\n            }\n            if(p<r && '1'<=sr[p] && sr[p]<='9'){//如果括号后面是数字\n                ll l_t=p,r_t=p+1;\n                while(r_t<r && '0'<=sr[r_t] && sr[r_t]<='9')  r_t++;\n                solve(i+1,p-1,number(l_t,r_t)*power);\n                i=r_t-1;\n            }\n            else{//如果括号后面不是数字\n                solve(i+1,p-1,power);\n                i=p-1;\n            }\n        }\n        else{//如果是小写字母\n            if(i+1<r && '1'<=sr[i+1] && sr[i+1]<='9'){//如果字母后面是数字\n                ll l_t=i+1,r_t=i+2;\n                while(r_t<r && '0'<=sr[r_t] && sr[r_t]<='9')  r_t++;\n                cnt[sr[i]]=cnt[sr[i]]+number(l_t,r_t)*power;\n                i=r_t-1;\n            }\n            else{//如果后面不是数字\n                cnt[sr[i]]=cnt[sr[i]]+power;\n            }\n        }\n    }\n    return ;\n}\nvoid init(){\n    memset(cnt,0,sizeof(cnt));//cnt数组初始化\n}\nvoid out(){//输出函数\n    for(char i='a';i<='z';i++){\n        if(cnt[i]==0)  continue;\n        cout<<i<<\" : \"<<cnt[i]<<endl;\n    }\n    cout<<endl;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    while(cin>>sr){\n        init();\n        solve(0,sr.length(),1);\n        out();\n    }\n    return 0;\n}\n```\n\n头一次发现自己也能写出来这么优雅简介的代码了,main函数里几个函数就搞定了(窃喜)","tags":["比赛"]},{"title":"前缀和Substring","url":"/2021/08/29/前缀和Substring/","content":"\n前缀和与Substring的爱恨情仇 \n<!--more-->\n\n\n# 前缀和妙用-经典套路\n[Command Sequence HDU - 7108](https://vjudge.net/problem/HDU-7108)\n题意，给一个只含UDRL的长度为n<1e5的串，问有多少子串的U个数==D个数,R个数==L个数，(个数可以为0).\n\t又是一道子串的题目，前缀和就是为子串量身定制的吧。\n\t前缀和妙用，真的太妙了。感觉这道题可以延伸一下，但是现在在寝室，有人打游戏太吵了，静不下心来，延伸不了。。\n\t\n![在这里插入图片描述](https://img-blog.csdnimg.cn/05fb2336ecca4ddc9c032311a2d9202b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWFyaG9vc2g=,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n\n**原来map可以pair到value，牛啊，map**\n\n<details>\n  <summary>点击查看代码</summary>\n  <pre><code>  \n\t\n```cpp\n#include<iostream>\n#include<map>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff//10^9级别，不到2^32\ntypedef long long ll;\nconst ll maxn=1e5+11;\nmap<pair<ll,ll>,ll> mp;\npair<ll,ll> pir[maxn]; \nchar ar[maxn];\nll ai[maxn],bi[maxn];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll t;\n    cin>>t;\n    while(t--){\n        ll n;\n        cin>>n;\n        mp.clear();\n        ai[0]=bi[0]=0;  pir[0].first=ai[0],pir[0].second=bi[0];\n        mp[pir[0]]++;\n        for(ll i=1;i<=n;i++){\n            cin>>ar[i];\n            if(ar[i]=='U')  ai[i]=ai[i-1]+1;\n            else if(ar[i]=='D')  ai[i]=ai[i-1]-1;\n            else  ai[i]=ai[i-1];\n            if(ar[i]=='R')  bi[i]=bi[i-1]+1;\n            else if(ar[i]=='L')  bi[i]=bi[i-1]-1;\n            else bi[i]=bi[i-1];\n            pir[i].first=ai[i],pir[i].second=bi[i];\n            mp[pir[i]]++;\n        }\n        ll ans=0;\n        for(ll i=0;i<=n;i++){\n            ans+=mp[pir[i]]-1;\n        }\n        cout<<ans/2<<endl;\n    }\n    return 0;\n}\n```\n\n  </code></pre>\n</details>\n\n# 4⭐二维前缀和好题\n[ Portal](https://codeforces.com/contest/1581/problem/C)\n\n题意：最少需要改多少个元素，能形成需要的形状\n\n思路：\n直接暴力n^4方会超时。如果是确定矩形形状，再枚举矩形位置的情况话，不好剪枝。\n相反，如果是确定了位置和矩形的行数，再枚举矩形的列数的话，就可以剪枝。\n当枚举最后一列之前，判断是否大于16，大于就剪枝，16是最坏情况下的修改数。\n\n踩坑：\n算y前缀和的时候，y写成了, y[j][i]=y[j-1][i]+(a[j][i]=='1');\n正确的是:\n```cpp\nfor(ll i=1;i<=n;i++){\n    for(ll j=1;j<=m;j++){\n        x[i][j]=x[i][j-1]+(a[i][j]=='1');\n        y[i][j]=y[i-1][j]+(a[i][j]=='1');\n        s[i][j]=s[i][j-1]+s[i-1][j]-s[i-1][j-1]+(a[i][j]=='1');\n    }\n}\n```\n\n","tags":["基本算法"]},{"title":"ACM比赛划水记录","url":"/2021/08/29/ACM比赛划水记录/","content":"\nTest!Test!  “           ” 比赛！比赛！\n\n<!--more--> \n\n# 2021.8.28 ccpc网络赛\n众所周知 2021年8.28没有CCPC网赛\n只有CCPC“网络”选拔赛\n\n## 涨姿势了\n[Power Sum HDU - 7105 ](https://vjudge.net/problem/HDU-7105)\n![](https://img-blog.csdnimg.cn/50c9d6eaf04e411183ed37159528eccb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWFyaG9vc2g=,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\t当时想到了平方差凑数，可惜差一步。不难发现，x方-(x+1)方-（x+2）方+（x+3）方=4；那么我们直接让n%4，接下来只要凑出0,1,2,3即可，0不用考虑，1的话就是1方，2的话就是4方-3方-2方-1方，3的话就是2方-1方。于是我们就可以凑出n了。注意到这里k最大为n+2，不过我们按照这个方法凑出来的刚好最大长度也是n+2。\n\t\n！！！！！！！\n注意下这里的输出，因为输出最多有1e6，用字符串输出会更快\nprintf输出指定长度字符串的方法是：printf(\"%.*s\\n\",l,ar);很离谱的是用这个输出 C++WA，G++AC。。。\n字符串输出指定长度,除了用上面这种不太靠谱的方法,还有就是用string,对于string,可以直接加上一个字符串\"1001\",比一个个push_back快一些.\n还有就是对于分情况对数赋值，可以直接用个数组来弄，就像方向数组，比ifelse代码简介不少。\n可以对比下两个代码，就知道代码量的区别了。\n本弱鸡代码：\n\n```cpp\n#include<stdio.h>\ntypedef long long ll;\nconst ll maxn=1e6+11;\nchar ar[maxn];\nint main(){\n    ll t;\n    scanf(\"%lld\",&t);\n    while(t--){\n        ll n;\n        scanf(\"%lld\",&n);\n        ll cnt=n/4;\n        ll ys=n%4;\n        ll tmp=0;\n        if(ys==0){ ; }\n        else if(ys==1){\n            ar[tmp++]='1';\n        }\n        else if(ys==2){\n            ar[tmp++]='0',ar[tmp++]='0',ar[tmp++]='0',ar[tmp++]='1';\n        }\n        else if(ys==3){\n            ar[tmp++]='0',ar[tmp++]='1';\n        }\n        for(ll i=0;i<cnt;i++){\n            ar[tmp++]='1',ar[tmp++]='0',ar[tmp++]='0',ar[tmp++]='1';\n        }\n        printf(\"%lld\\n\",tmp);\n        printf(\"%.*s\\n\",tmp,ar);\n    }\n    return 0;\n}\n\n```\n\n高质量代码\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint t, n;\nconst int ki[] = {0, 1, 4, 2};\nconst string ti[] = {\"\", \"1\", \"0001\", \"01\"};\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> t;\n    while (t--) {\n        cin >> n;\n        string ans = ti[n % 4];\n        int k = ki[n % 4];\n        while (n >= 4) {\n            ans += \"1001\";\n            k += 4;\n            n -= 4;\n        }\n        cout << k << endl << ans << endl;\n    }\n    return 0;\n}\n```\n\n！！！！！！！\n  </code></pre>\n</details>\n\n\n## 经典套路-好题\n[Command Sequence HDU - 7108](https://vjudge.net/problem/HDU-7108)\n题意，给一个只含UDRL的长度为n<1e5的串，问有多少子串的U个数==D个数,R个数==L个数，(个数可以为0).\n\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\t又是一道子串的题目，前缀和就是为子串量身定制的吧。\n\t前缀和妙用，真的太妙了。感觉这道题可以延伸一下，但是现在在寝室，有人打游戏太吵了，静不下心来，延伸不了。。\n\t\n![在这里插入图片描述](https://img-blog.csdnimg.cn/05fb2336ecca4ddc9c032311a2d9202b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATWFyaG9vc2g=,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n！！！！！！！！！！！！！！！！！！！！！\n原来map可以pair到value，牛啊，map\n！！！！！！！！！！！！！！！！！！！！！\n\n  </code></pre>\n</details>\n\n# 2021.8.29 混合组队赛\n[676 C Vasya and String](https://codeforces.com/problemset/problem/676/C)\n题意：给你一个长度为n<1e5的只含a，b的串，可以允许修改k个位置，问能得到最长的“一样串”的长度是多少。“一样串”即只含a或只含b的串。\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\t先讨论只含a的情况，尺取即可，b同理。\n  </code></pre>\n</details>\n\n[1469 B Red and Blue](https://codeforces.com/problemset/problem/1469/B)\n题意：给你两个长度分别为n和m的整数列a和b，将a和b数列并成一个数列c，即c的长度为n+m，要求数列c中，对于a的每个数保持原先a的顺序，b同理。问c的最大前缀和。\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\t贪心，整数不用多说，对于a中的负数，只要后面有正数能使其和为正，则加上这个负数，无则不加。b同理。\n  </code></pre>\n</details>\n\n## 巧用，看思路\n[988 C Equal Sums](https://codeforces.com/problemset/problem/988/C)\n题意：给你k<2e5个数列，每个数列长度为ni,数据保证ni的和<2e5，每个数的范围为−1e4  to 1e4。从中任意选择两个数列，两个数列必须减去有且仅有各自的一个数后，若两个数列的和相等，则输出这两个数列的序号ni，和减去的数。若不存在这样的两个数列，输出NO。结果多组情况输出一组即可，ni可以任意顺序输出。\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\t我一开始想复杂了，想着这就是不能有重复元素，我就先把每个数列去个重，然后再把他们都弄到一个数列里面，排个序看是否有重复元素。\n\t简单方法就是，判断有无重复元素，直接看a[i]是否等于1就可以了嘛，但这道题由于i最大为1e9，所以需要hash或者map，平常的map是map[i]=k，然后再拉个结构体数组存数列ni和x，\n\n！！！！！！！！！！！！！\n这里有个简单方法就是直接将i映射为pair,pair存的就是ni和x，举一反三我们以后也可以将i map到一个结构体\n注意下这里的map的赋值操作：mp[sum]=make_pair(i,j);，结构体的话直接=号赋值就可以了。\n！！！！！！！！！！！！！\n  </code></pre>\n</details>\n\n## 总结\n\n做了三个签到题，其余全靠队友带飞，数学大佬hly，图论大佬ly。这次比赛体验良好，跟队友配合的都挺好的。刚好我们看的题，都是自己擅长的(滑稽\n  还有**代码能力有待加强，主要是细节错误挺多，写个尺取都要wa。。。**\n\n\n# 2021.9.5 线段树专题测试\n有些题能模拟，但是纯模拟会很麻烦，细节很多，基本写不了，而且关键自己写着写着会把自己心态写炸。为避免这种模拟题写到一半发现写不了的尴尬情况，应该提前想好大致思路，确定能写在写。\n\n# 2021.9.10 2021第十一届山东省大学生程序设计竞赛\n[比赛](https://ac.nowcoder.com/acm/contest/15600#question)\n咳咳，蒟蒻，全靠hly大佬带飞\n过了5道，CDGHM  一队过了7道，剩下的两道有机会出的，说明运气好，把会做的都做了还是能拿金的。\nF题字符串思路想到了，可惜没有码出来。\nB题想复杂了，一看要算n*n个gcd，就以为是自己没学过的知识，不敢下笔了，以后不要怕！至少要分析一波，分析不出来就算了，不能分析都不分析就放弃。\n因为这道题n很大的时候，是有特殊情况，可以直接输出的。。。\n\n## 思维题可还行\n[C Cat Virus](https://ac.nowcoder.com/acm/contest/15600/C)\n题意：给定一棵树，黑白染色方案，满足一个黑点的子树都是黑点，白点任意。你现在构造一棵树，使得它的染色方案数为K(1<=k<=1e18)\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n思想：按hly的思路，首先是想到一条链，然后这条链长度为n，方案数就是n+1，但不过K太大，输出会超限。\n然后想到以1为根节点，其下有n个**子树**，大佬的想法就是不一样，直接子树，统一处理。\n然后这n个子树，每个子树的涂色方案为ai,那么整棵树的方案就为a1到an的乘积+1。\n按照这个思路，我们一开始以1为根节点，剩余方案数为k-1，如果k-1%2==0，则在1下增加一个子节点，如果方案数ki%2仍==0，则继续在1下增加子节点，\n当遇到奇数时，我们则想到一开始的k-1，所以我们就以这个子结点为根结点，开一个新树，递推即可。\n  </code></pre>\n</details>\n\n\nDG签到题，H二维背包，表示不会。。\n\n## 思维题有点意思 \n[M \tMatrix Problem](https://ac.nowcoder.com/acm/contest/15600/M)\n题意：给定0/1矩阵C，n行m列，(n,m<500)构造两个矩阵A,B,要求A,B各自的1都互相连通，并且对于C中所有位置，若是1，则A,B对应位置必须都是1,否则，A为0则B为1，B为0则A为1。保证C阵的边框都是0。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n思路：这种构造A，B矩阵输出的题，一般是按规律构造的，几乎不可能想着模拟去构造，太麻烦，比如本题。\n注意到这个保证边框都是0没，可以从这里做文章，把A最左边一列是1，B最右边一列是1，然后行分奇偶全染成1。\n  </code></pre>\n</details>\n\n## 最小生成树+GCD可还行\n[B Build Roads](https://ac.nowcoder.com/acm/contest/15600/B)\n题意：给定一个n<2e5个点的无向完全图，i和j之前的边权是gcd(ai,aj),数组ai范围在[l,r]<2e5,保证数组a随机,求MST。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n思路：考虑素数分布， int 范围内两个素数之间的最大间距不到几百，（算了一下，是282，1e9范围内素数50847534个）而如果随出来的数组里有素数答案就是n-1\n了，所以[l,r]或n范围很大时答案就是n-1,但注意如果[l,r]范围很大n很小，那么就得gcd(a1....an)乘(n-1)。范围很小的时候暴力一下就行了。还需要稍微注意一下l==r的情况。\n\n  </code></pre>\n</details>\n\n# 2021.9.12 排位赛\n又是爆0的一天呢\n\n## DFS BFS傻傻分不清\n[C Brexit](http://codeforces.com/gym/101490/attachments)\n题意：给一个n<1e5个点，m<1e5条边的无向图，删去其中某个点，如果剩余的点中，删去的边数*2>=初始有的边数，则删去这个点，如此连环反应，问最终x点是否会被删去。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n思路：一开始想着写dfs，因为dfs简单些，然后就dfs哇了n遍，改成bfs一遍过了。究其根本原因是dfs的搜索方式与这道题不符，所以这道题用dfs是出不了的。这道题很明显是得用bfs搜的。\n  </code></pre>\n</details>\n\n## Dijskra好题\n[E Charles in Charge](http://codeforces.com/gym/101490/attachments)\n题意：1e5级别的图，求从a点到b点的所有不大于l的路中，每条路的最大边长的最小值。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n思路：很明显直接dfs搜会超时，正确做法二分边长，对于二分的边长mid，将边长小于mid的边来建图。\n  </code></pre>\n</details>\n\n# 2021 ICPC 网赛 第二场\n\nL题思路想到了，可惜最后只有半个小时来码代码，加上不熟，不然能出😂\n\n## 思维题\n\n题意\n\n![](/uploads/ACM比赛划水记录/2021-09-27-20-20-42.png)\n\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n思路：就正常的二进制按位加法，然后分类讨论下不同符号位对应的本位和进位情况。\n\n  </code></pre>\n</details>\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-27 19:05:00\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e2+11;\nll a[maxn],b[maxn],s[maxn],ans[maxn];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;cin>>n;\n    for(ll i=1;i<=n;i++)  cin>>s[i];\n    for(ll i=1;i<=n;i++)  cin>>a[i];\n    for(ll i=1;i<=n;i++)  cin>>b[i];\n    for(ll i=1;i<=n;i++){\n        ll x=ans[i]+a[i]*s[i]+b[i]*s[i];\n        if(s[i]==1){\n            if(x==-1){\n                ans[i+1]=-1;\n                ans[i]=1;\n            }\n            else{\n                ans[i+1]=x/2;\n                ans[i]=x%2;\n            }\n        }\n        else{\n            if(x==1){\n                ans[i+1]=1;\n                ans[i]=1;\n            }\n            else{\n                ans[i+1]=x/2;\n                ans[i]=-1*x%2;\n            }\n        }\n    }\n    for(ll i=1;i<=n;i++){\n        if(i==n)  cout<<ans[i];\n        else  cout<<ans[i]<<\" \";\n    }\n    return 0;\n}\n\n```\n\n\n## Segment Tree beats 维护一个数列\n题意\n\n![](/uploads/ACM比赛划水记录/2021-09-27-20-22-39.png)\n\n![](/uploads/ACM比赛划水记录/2021-09-27-20-22-49.png)\n\n这里对于100以内的25个质数的维护，可以状态压缩，即用一个int的一位二进制表示改质数是否存在。也就是再拉个线段树维护25个质数。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define Debug(x)  cout<<#x<<\": \"<<x<<endl;\n#define lson l,m,now<<1\n#define rson m+1,r,now<<1|1\ntypedef long long ll;\nconst ll maxn=1e5+11;\nconst ll mo=998244353;\nll t[maxn<<2],rr[maxn<<2],x[maxn],lazy[maxn<<2],ar[111];\nll tmp;\nll is(ll x){\n    for(ll i=2;i*i<=x;i++)  if(x%i==0)  return 0;\n    return 1;\n}\nvoid init(){\n    tmp=0;\n    for(ll i=2;i<=100;i++){\n        if(is(i))  ar[tmp++]=i;\n    }\n}\nll fy(ll x){//计算x的欧拉值\n    ll ans=x;\n    for(ll i=0;i<25;i++){\n        if(x%ar[i]==0){\n            ans=ans*(ar[i]-1)/ar[i];\n        }\n    }\n    return ans;\n}\nll wei(ll x){\n    ll ans=0;\n    for(ll i=0;i<25;i++){\n        if(x%ar[i]==0){\n            ans=ans|(1<<i);\n        }\n    }\n    return ans;\n}\nvoid push_up(ll now){\n    t[now]=(t[now<<1]+t[now<<1|1])%mo;\n    rr[now]=rr[now<<1]&rr[now<<1|1];\n}\nvoid push_down(ll l,ll r,ll now){\n    if(lazy[now]>1){\n        t[now<<1]=t[now<<1]*lazy[now]%mo;\n        lazy[now<<1]=lazy[now<<1]*lazy[now]%mo;\n        t[now<<1|1]=t[now<<1|1]*lazy[now]%mo;\n        lazy[now<<1|1]=lazy[now<<1|1]*lazy[now]%mo;\n        lazy[now]=1;\n    }\n}\nvoid build(ll l,ll r,ll now){\n    lazy[now]=1;\n    if(l==r){\n        t[now]=fy(x[l]);rr[now]=wei(x[l]);\n        return ;\n    }\n    ll m=l+((r-l)>>1);\n    build(lson);build(rson);\n    push_up(now);\n}\nvoid update(ll L,ll R,ll w,ll val,ll l,ll r,ll now){\n    if(L<=l && r<=R && (rr[now]&val)==val){\n        t[now]=t[now]*w%mo;lazy[now]=lazy[now]*w%mo;\n        return ;\n    }\n    if(l==r){\n        t[now]=t[now]*w;\n        for(ll i=0;i<25;i++){\n            if(((rr[now]>>i)&1)==0 && ((val>>i)&1)==1){\n                t[now]=t[now]*(ar[i]-1)/ar[i];\n            }\n        }\n        t[now]=t[now]%mo;\n        rr[now]=rr[now]|val;  \n        return ;\n    }\n    ll m=l+((r-l)>>1);\n    push_down(l,r,now);\n    if(L<=m)  update(L,R,w,val,lson);\n    if(R>m)  update(L,R,w,val,rson);\n    push_up(now);\n}\nll getsum(ll L,ll R,ll l,ll r,ll now){\n    if(L<=l && r<=R)  return t[now];\n    ll m=l+((r-l)>>1);\n    push_down(l,r,now);\n    ll sum=0;\n    if(L<=m)  sum=getsum(L,R,lson)%mo;\n    if(R>m)  sum=(sum+getsum(L,R,rson))%mo;\n    return sum;\n}\nint main(){\n    init();\n    ll n,m;cin>>n>>m;\n    for(ll i=1;i<=n;i++)  cin>>x[i];\n    build(1,n,1);\n    for(ll i=1;i<=m;i++){\n        ll op,l,r,w;\n        cin>>op;\n        if(op==0){\n            cin>>l>>r>>w;\n            if(w==1)  continue;\n            update(l,r,w,wei(w),1,n,1);\n        }\n        if(op==1){\n            cin>>l>>r;\n            cout<<getsum(l,r,1,n,1)<<endl;\n        }\n    }\n    return 0;\n}\n\n```\n\n# 2021.9.26排位赛\n\nJ题最后10几min做出来了，而且是压着时限过的，真是刺激。\n\n## 思维题(easy-medium)\n\n[Elegant Construction HDU - 5813](https://vjudge.net/problem/HDU-5813);\n\n题意：给一个有向图，n<1e3个点，接下来n个数表示与第i个点直接或间接相连的点的个数。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n![](/uploads/ACM比赛划水记录/2021-09-27-23-52-05.png)\n\n  </code></pre>\n</details>\n\n## 模拟-思维(easy-medium)\n\n[https://acm.hdu.edu.cn/showproblem.php?pid=5818](https://vjudge.net/problem/HDU-5818)\n\n解题思路挺多的：\n\n1、标解：\n\n![](/uploads/ACM比赛划水记录/2021-09-28-00-05-22.png)\n\n2.启发式合并\n\n合并的时候都是选择将小的栈合并到大的\n\n3、指针前驱\n\n[转载](https://blog.csdn.net/queuelovestack/article/details/52164782)\n\n# 2021.10.17排位赛\n\nC题题目老长了，定义了一堆变量，结果全是烟雾弹，真正有用的话就一句，晕晕\n下次不要再被长题面吓到了\n\n# 2021.10.18 排位赛 2020ICPC上海站\n\n1.B题是个思维构造题，没想到\n\n2.D题有两种做法\n\n1.二分\n\n可以二分时间，也可以二分路程。\n\n2.分类讨论\n\n不过这个分类讨论挺复杂的，惊讶于这么复杂的分类讨论，我们当时居然过了！！！\n真的是十分Amazing，主要得益于当时分类讨论的思路清晰，看来只要思路清晰，啥题都能做出来\n而且一道题目真的有多种解法，比如这道题。\n\n\n\n\n\n\n\n","tags":["比赛"]},{"title":"2015ICPCWorldFinal","url":"/2021/08/28/2015ICPCWorldFinal/","content":"\nThe best of the best of the best\n一场完美的归来，更是一场无双的谢幕。\n\n<!--more--> \n[转载](https://www.cnblogs.com/chxer/p/4524716.html)\nWorld Final题目连接：http://icpc.baylor.edu/worldfinals/problems/icpc2015.pdf \n\n建议：可以倒序阅读来获得最直观的赛场体验。。。\n\n \n\n2:12 感想：。。。。\n\n第一次看了ACM WF的全过程，还是有点激动的呢。\n\n其实，算法、程序真的是一种心灵的休憩，只要乐在其中，给人生增添一点光彩，那就够了。\n\n                                                            \n\n \n\n2:00 World Final Campion！ITMO！Tourist！The First In The History!\n\n\n\n\n\n\n\n\n\n\n\n1:55 咳咳，此处要空一下，酝酿一下气氛！！！！！\n\n1:54 莫斯科大学第二。。。祝贺。。。\n\n\n\n1:51 东京大学第三。。。祝贺。。。\n\n\n\n1:46 清华的L竟然Wa了？真没想到。。。不过金牌很好了\n\n\n\n1:44 真理了：\n\n\n\n1:43 我不敢相信怎么还三千多个人呢。。。\n\n\n\n1:42 北大第五呜呜呜。。。。\n\n1:37 上海交大，唉。。。去年叉姐带着还是第二名呢。。。\n\n1:21 圣彼得国立大学怎么了这是。。。\n\n1:14 浙大过去了，浙大下一届一定加油啊！\n\n1:12 非洲冠军播报完毕，清华加油！还有一小会！！！清华一定拿金啊！！！！\n\n1:05 开始揭榜！被“The second is yes and they move up!”洗脑了。。。\n\n\n\n0:57 要揭了！\n\n0:54 老头整理了一遍以前的冠军（每次都要干啊= =）\n\n0:52 那个老头还没说完= = tourist低着头肯定在hack呢= =\n\n0:43 发了FB的奖:\n\nA题FB：北京大学\n\nC题FB：清华大学\n\n而且。。。似乎只是发了一个北京大学作为代表= =\n\n0:30 泰国老兄讲话，下一届在泰国！CLJ哭了= =\n\n0:29 老爷爷好萌！\n\n\n\n0:26 开始讲话了。。。我要睡觉。。。\n\n0:13 观众终于入座，闭幕式开始。\n\n0:09 正式开始！！！\n\n0:02 然而，直播间仍然有7000左右个人因为大家实在是太想看叉姐吃键盘了！！！\n\n0:01 榜还没有揭！！！还在播广告！\n\n0:00 所有人都在吐槽这个短片已经看了三遍了QAQ\n\n23:51 大家：这段广告似乎放过一遍了？= =我也是这么觉得的。。。\n\n23:47 还是在播广告！是不是tourist真的去hack了。。。\n\n23:42 叉姐果断买了键盘。。。\n\n23:39 还有广告QAQ\n\n23:37 颁奖典礼开始\n\n23:33 然而tourist还不满足：“我还要hack你们别拦我！”= =\n\n23:32 大家纷纷让叉姐吃popoQQQ大神，Q大神很迷茫的走入镜头。。。\n\n23:31 榜还没有揭。。。\n\n23:29 今天是第一个WF的AK之日，也是第一个退役队员的吃键盘之日\n\n23:28 大家纷纷安慰CLJ：明年去15题AK超过tourist好了。。。\n\n23:27 快准备好颁奖仪式！\n\n23:18 mayur传来准确消息，tourist AK了！！！\n\n\n\n23:15 没有人数清楚因为很明显给P掉了！但是现场有人说已经AK了\n\n23:13 有直播了，大家开始数气球了。。。\n\n23:12 榜已更，还有20分钟揭榜大家休息一会= =\n\n23:11 还有三分钟开榜\n\n23:10 准备颁奖仪式\n\n23:09 准备结束\n\n23:07 各种消息称：tourist真的AK了，史上第一位WF AK的神犇：\n\n\n\n现在直播间满屏的“叉姐吃键盘”：\n\n\n\n\n\n23:03 CLJ说touristAK了\n\n比赛结束，最后的榜：\n\n\n\n23:00 比赛结束。\n\n22:58 petr被采访了。。。看来是要阻止其继续发Twitter\n\n22:57 CLJ快帮我们看看ITMO跳起来没有！！！！\n\n22:55 天哪！！！tourist交K了！！！交K了！！！交K了！！！交K了！！！交K了！！！\n\n22:54 petr的K题图论题的题解发了，是桥神马的\n\n22:52 清华大学交了两发B，不知道怎么样\n\n22:50 最新消息，北京大学第七，清华大学第四，东大第三，莫斯科第二，ITMO准备AK\n\n22:47 比赛现场已经不送气球了，最后的20分钟tourist加油啊！\n\n22:46 北大清华并没有什么行动，现在形成了6校抗日的联合局面。\n\n22:45 东大又交了一发B，估计Wa了？\n\n22:44 tourist开始K了，绝杀啊加油\n\n22:43 出题人正在分析题目难度，签到题果断全都easy\n\n22:41 东大的B题Wa了。。。\n\n22:36 petr说tourist过了B了，现在莫斯科必须AK才可能拿到第一名。\n\n22:34 有传言说tourist已经AK了正在睡觉= =\n\n22:33 莫斯科过M了！！！跟tourist打平（我们一直在说tourist而不是ITMO。。。）\n\n22:32 东大在问裁判问题，tourist又打了个哈欠继续码。。。\n\n22:28 莫斯科在写M\n\n22:27 petr说ITMO正在攻B题计算几何。。。莫斯科笑了\n\n22:25 petr正在推特上直播情况。。。\n\n22:21 根据现场选手表情可以看出tourist和东大都过了，tourist还差2道，东大落后一道。\n\n22:19 tourist交了G，东大交了K。\n\n22:15 上海交大逆袭，封榜后一下子交了三道题我去，，，这是要进金啊。。。\n\n22:07 封榜，现在局面是清华北大抢金牌，tourist看看怎么AK\n\n22:06 北大过了E，把清华踩在脚底了。。。\n\n22:04 封榜前的冲刺，莫斯科还是唯一一个过计算几何的队伍。\n\n21:57 加利福尼亚Wa了M题，清华有戏。\n\n21:55 陈丽洁在场外伤心死了。。。\n\n21:53 清华再交，A！！！清华现在第四！\n\n21:52 清华的M跪了\n\n21:51 还有十分钟封榜。tourist：封榜之时，AK之日。\n\n21:44 大家纷纷议论清华北大是屯了多少题= =\n\n21:39 tourist还差最后一道题没有屯完。。。“我屯完了啊让我睡一会，帮我盯着东大什么时候做完咱的一半。。。”\n\n21:33 东大的M题Wa了N发，ITMO确定夺冠了。。。\n\n21:27 现在形势：ITMO十题；东大，莫斯科九题；清华北大加利福尼亚八题但加利福尼亚是第四！\n\n21:25 tourist口型：“看我AK”。。。\n\n21:22 抗日奇侠tourist以最高分过E把东大赶下台了= =\n\n21:20 北大被加利福尼亚撵出了金牌线。。。\n\n21:06 天哪东大过E了！！！东大第一了！！！tourist突然起身啊。。。\n\n21:05 莫斯科过B了！！！tourist的FB被抢走了！！！\n\n20:58 清华北大八题AC排4,5\n\n20:56 tourist跟队友讨论是不是现在AK还是等一会给其他学校一点面子。。。\n\n20:53 tourist碾压九题，站起来笑了笑。。。\n\n20:38 C题签到完毕。tourist过了M的样例了，淡定的打了个哈欠。。。\n\n20:35 北大换李超上去码了。\n\n20:34 ITMO交了M！可惜Wa的好惨；tourist还不做L 相信自己五分钟能1A。。。\n\n20:31 东大第八题Wa了。。。\n\n20:30 东大八题了。。。出题人公布E题了，竟然是DP！！！\n\n20:29 清华七题1A，tourist开始码了。。。\n\n20:22 tourist开始虐场了，ITMO刷掉8题，tourist的队友都开始睡觉了！\n\n20:20 北大七题第三，同时A题签到完毕\n\n20:05 叉姐说去年他那届题多么多么难，今年题多么多么简单= = VFK很看好后期的上海交大。。。。\n\n20:04 东大七题到手，金牌稳了。。。\n\n20:02 直播吃外卖的叉姐表示对题目全是吃的感觉异常愤怒，同时大呼这次他应该上。。。码力十足啊！\n\n19:52 命题人讲解C，果然考的MCMF！！！ \n\n19:46 清华主代码手开始打字了= = \n\n19:36 东大逆天，第六题1A，（毕竟计算几何东大太强了！！！） \n\n19:32 清华东大掉掉掉，叉姐说L题可以用哈夫曼树搞。 \n\n19:20 北大清华复旦排名三四五，东京大学第一225，莫斯科第二261，B还是没有学校过据说出难了。 \n\n19:17 圣彼得堡四题到手，清华升到第四 \n\n19:10 现在北京大学三题第一，日本大学随后，清华大学一直在waC题，排13 ","tags":["ACM有点意思"]},{"title":"倍增","url":"/2021/08/26/倍增/","content":"\n倍增？二分？递归？递推！\n\n<!--more--> \n\n# 题单\n- [ ] CodeForces - 359D  (-[x]打钩方法)\n\n# 倍增法\n本质：吾以为倍增法本质就是将二分的过程存了下来，二分本来是个递归的过程嘛，倍增法就是将其变成递推了。比如二分可以将其划为两个子问题求解，这两个子问题可以是重复性贡献，也可以是不重复性贡献的，然后再用递推式将其求出来。更详细的理解可以见例题\n倍增法本身的复杂度是O(n*logn)的，然后可以O(1)的查询，所以倍增法适用于多次询问的情况，如果只有1次询问的话，就没必要倍增了，直接算就行了。但倍增本身复杂度也不高，O(n*logn)，也可以用来解决1次询问情况，不过就是有些大材小用了。\n\n\n\n## ST表\n模板\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn=1e5+11;\nll n,ans[maxn*10],st[maxn][17];//2的17次方比1e5大一点\n//求区间最大值\nvoid init(){//st表初始化\n    for(ll j=1;(1<<j)<=n;j++)\n        for(ll i=1;i+(1<<j)-1<=n;i++)\n            st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);\n//划分为两个子问题求解，这两个子问题是可重复性贡献的\n}\nll query(ll l,ll r){//区间[l,r],注意是闭区间，返回区间[l,r]的最大值\n    ll k=0;while(l+(1<<k+1)-1<r)k++;\n    return max(st[l][k],st[r-(1<<k)+1][k]);//不直接找一个大区间覆盖而是要找两个小区间合并是因为大区间可能超过了st表的长度\n}\n```\n### ST表-二维RMQ\n[ST表-二维RMQ](https://blog.csdn.net/qq_42569807/article/details/89408623)\n## LCA-最近公共祖先\n[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)\n模板\n这个模板注意下dfs里面fa初始化的问题，要么直接设置为常数，要么就改为i<=lg2[d[now]-1],然后再在lca函数的if改成if (fa[x][k] != fa[y][k] && k <= lg2[d[x] - 1])  \n```cpp\n/*** \n * @Practice Win\n * 洛谷 P3379 【模板】最近公共祖先（LCA）\n */\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff//10^9级别，不到2^32\ntypedef long long ll;\nconst ll maxn=5e5+11;\nstruct Edge{\n\tll to,next;\n}edge[maxn*2];//edge的边数要乘2\nll head[maxn],d[maxn],fa[maxn][22],lg2[maxn],tmp=1;\n//d[i]是结点i的深度，fa[i][j]表示i的第2的j次方父结点，lg2[i]是log2(i)取整数\nvoid add(ll u,ll v){\n\tedge[tmp].to=v;\n\tedge[tmp].next=head[u];\n\thead[u]=tmp++;\n}\nvoid dfs(ll now,ll far){//预处理d与fa数组\n\tfa[now][0]=far,d[now]=d[far]+1;\n\tfor(ll i=1;i<=20;i++)  fa[now][i]=fa[fa[now][i-1]][i-1];//这个常数20对应的是1e6!!!!!!!!!!\n\t//不用d[now]是因为多样例根节点不同的时候，因为在lca那个if里面k可能会比较大，然后指向不一样\n\tfor(ll i=head[now];i;i=edge[i].next){\n\t\tif(edge[i].to!=far)   dfs(edge[i].to,now);//这里记得加个条件，不能到父节点\n\t}\n}\nll lca(ll x,ll y){//输入两个结点编号，x与y，返回x和y的lca\n\tif(d[x]<d[y])  swap(x,y);\n\twhile(d[x]>d[y])  x=fa[x][lg2[d[x]-d[y]]];//这里要while，因为这里的lg2不是精确值\n\t//这里re找了我好久错误！！！原来不是数组开太大了，也不是数组开太小了，是数组里的结果有负数！！！\n\tif(x==y)  return x;\n\tfor(ll k=lg2[d[x]-1];k>=0;k--){\n\t\tif(fa[x][k]!=fa[y][k]){//找到lca的下一层\n\t\t\tx=fa[x][k],y=fa[y][k];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nvoid init(){\n\tfor(ll i=2;i<maxn;i++)  lg2[i]=lg2[i/2]+1;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tll n,m,s;  cin>>n>>m>>s;//n个 结点,m次询问，以s为根节点\n\tinit();\n\tfor(ll i=1,u,v;i<=n-1;i++){\n\t\tcin>>u>>v;  add(u,v);add(v,u);//无向图！！！\n\t}\n\tdfs(s,0);\n\tfor(ll i=1,u,v;i<=m;i++){\n\t\tcin>>u>>v;  cout<<lca(u,v)<<endl;\n\t}\n    return 0;\n}\n\n\n```\n## RMQ灵活运用，求区间最常出现数字的数量\n[Frequent values POJ - 3368](https://vjudge.net/problem/POJ-3368)\n题意：给一个数列n，n是非递减序列，有重复数字。有q次询问，n,q<1e5，每次问在区间[l,r]内最经常出现的数字的数量。\n思路：将连续相同的数字看成一个块，预处理出每个块含有的数字的数量，以及块的右坐标。这个预处理出来的值可以封装成结构体减少空间。也可以直接在原数组的基础上，加两个数组num[i]表示i所处块含有的数字数量，pos[i]表示i映射到st表中的坐标。一开始我是用的第一个方法，麻烦了些，看了别人的题解知道第二个方法，确实方便些，直接以空间换时间，反正ACM竞赛嘛。对于每次查询，可以将答案分成三部分，左边残余块，中间连续一整块，用RMQ处理，右边残余块，取三者最大值即可。\n踩坑：**这个方法不适用于所有情况，就要分类讨论**，不要怕麻烦，如果这个方法不适用于所有情况，那就得分类讨论，不然偷懒的话，找BUG的时间你知道的，都够再写道题了。比如这里很明显，不是每次都有中间区间，如果每次都按有中间区间来算，就错了。可能l,r在一个块内，没有中间区间，l,r在两个相邻的块，也没有中间区间，当l,r中间隔一个块时，才有中间区间。然后这里又设计左右坐标的加减，没有一个统一的方法处理，很明显需要分类讨论。\n\n## LCA灵活运用，求树上两点间距离\n[How far away ？ HDU - 2586](https://vjudge.net/problem/HDU-2586)\n题意：给你一个无向树，求任意两点间距离，多次询问。\n思路：统一以某个点为根节点，记录每个点到根节点的距离，两点之间距离就等于lca到两点的距离之和。\n## 区间覆盖，倍增法好题\n[Minimal Segment Cover](https://codeforces.com/contest/1175/problem/E)\n题意：给你n个区间，有m次询问，n,m<2e5,每次询问区间A最少需要几个区间就能被完全覆盖，若不存在则输出-1。\n思路：这道题先要预处理一下，就很好做了，先预处理出以每个点为起点，只用一个区间能到达的最右端点。然后我们就会想知道，每个起点用2个区间，3个区间，n个区间向右最远能到哪。因为n最大为2e5，所以最多可以用2e5个区间，这个时候就要用上倍增的思想了，用dp[i][j]表示起点i用2^j个区间所能到达的最右端点，则dp[i][j]=dp[    dp[i][j-1]   ][j-1]。\n\n**代码有些细节**要注意：\n\n```cpp\nfor(ll i=1,l,r;i<=n;i++){\n    cin>>l>>r;v[l]=max(v[l],r);maxx=max(maxx,r);\n}\nfor(ll i=0;i<=maxx;i++){\n    v[i]=max(v[i-1],v[i]);\n    //因为v[i-1]也可能包含i这个点\n    dp[i][0]=v[i];\n}\nfor(ll j=1;j<=20;j++){\n    for(ll i=0;i<=maxx;i++){\n        dp[i][j]=dp[dp[i][j-1]][j-1];\n    }\n}\nfor(ll i=1,l,r;i<=m;i++){\n    cin>>l>>r;\n    ll ans=0;\n    for(ll j=20;j>=0;j--){\n        if(dp[l][j]<r){\n    //跳到r的上个点，来保证区间数最少\n            ans+=(1<<j);\n            l=dp[l][j];\n        }\n    }\n    if(v[l]>=r)  cout<<ans+1<<endl;\n    else  cout<<-1<<endl;\n}\n```\n\n## 树上与a，b距离相等的点有多少个\n[A and B and Lecture Rooms](https://codeforces.com/contest/519/problem/E)\n题意：如题，有多次询问\n思路：size[i]存下子树i的规模，求得lca点下层的两个点a,b，答案就为\nsize[lca]-size[a]-size[b]，答案具体的加减法不是这样，这只是表达个大概意思。\n\n## a中一区间是否存在子序列为p的一个排列-倍增好题\n[Lynyrd Skynyrd](https://codeforces.com/contest/1143/problem/E)\n题意：a,p,q<2e5，a是数列a长度，p是排列p长度，q是询问次数。子序列是指a的按相对顺序排列的序列，不是子串。p的一个排列是指循环排列。\n思路：懒得写了，看这篇吧，**注意其中的倍增思想**\n[题解](https://blog.csdn.net/qq_43202683/article/details/89220015)\n解释一下题解中第二个3，其前缀是1，1在a中是第二个位置。这样做是因为我们要贪心，找a中距离Ai最近的那个数组成排列。\n\n## 树中a的k级子孙有多少个-二分好题\n[Blood Cousins](https://codeforces.com/contest/208/problem/E)\n当然也可以树上启发式合并来做，但我不会，下次再学\n思路：对于求某个点的k级子孙，可以把树的每个结点按dfs序编号，记录每种深度含有的编号，记录每个结点，其子树的头个编号L[i]和最后一个编号R[i]。那么求其k级子孙，将其对应深度d，那么在所有深度为d的结点中，因为其结点编号按升序排序，所以可以二分的找到L[i]和R[i]的位置，两个位置之间的数量就为其k级子孙个数。\n\n## 3⭐ST表-GCD-二分-线段树慢\n[Pair of Numbers](http://codeforces.com/problemset/problem/359/D)\n题意：给一个长度为3e5的数列，记区间a为[l,r]，在区间a内存在一个数，使得所有区间a内的数都能整除它，求最长的区间a，若存在多个，则按左端点顺序从低到高输出。\n思路：\n1.朴素简单做法\n区间a内所有数都能整除它，那它一定是这个区间内的最小数。对于区间内一个数a1，我们求得以其为最小值的整除区间的最大长度，[l,r]，下次枚举，我们可以直接从a[r+1]开始枚举，因为对于a1到ar之间的数，他们的左端点最多为a1，右端点最多为ar，区间长度不会比a1的长。\n2.二分-ST表做法\n一开始想用线段树做，但是没考虑gcd的复杂度也是logn，然后就超时了，呜呜呜。用ST表就不会，因为ST表把每次GCD的值保存了下来，**这里可以仔细考虑下线段树和ST表的复杂度差别。然后我一开始用ST表写，是没想到二分长度l的，我是想着一边建表，一边update，但是这样子模拟很麻烦，不好写代码，虽然复杂度肯定比较低，但是没二分来的逻辑清晰，代码好写，况且二分的复杂度是够的！！！**二分的具体做法，在这里我们建两个ST表，一个最小值的，一个gcd的，如果gcd==minn，就是可以的，然后二分长度，对于每个长度，我们枚举n个数。所以复杂度是O(n*logn)的。\n\n## 倍增，贪心，超时？\n题目大意：给出一棵初始时只有一个点的树，每个点都有两个值:ai,ci,分别代表黄金的个数和单价。需要执行m<3e5次操作，每次操作分为两种类型：\n1 pi ai ci  添加一个新点,pi为其父节点,保证ci>c(pi)\n2 v w :需要从点v到根节点的这条路径上采集w个单位的黄金，问如何采集才能使得总花费最少\n注意对于每次操作2是会叠加的,即采集的黄金会拿走掉，下次能拿的黄金就变少了，且强制在线输出。\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n注意到ci>c(pi),就很简单了，就贪心，每次从根节点开始拿即可，关键是找到离根节点最近的非空结点。**但是我当时想的是一个一个拿会不会超时，如果真要卡的话，确实能卡掉，但是，现在一想，这样的数据造不出来！！！再者，考试的时候也可以试一试嘛，万一数据水了呢？超时就再说嘛，试了还有机会，不试就肯定没机会**那么直接简单倍增+贪心就可以了。\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-09-04 21:45:32\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-17 20:13:34\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=3e5+11;\nll fa[maxn][22],a[maxn],c[maxn];\nll found(ll x){\n    for(ll i=20;i>=0;i--){\n        if(a[fa[x][i]])  x=fa[x][i];\n    }\n    return x;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll q;cin>>q>>a[0]>>c[0];\n    for(ll i=1,op,vi,wi;i<=q;i++){\n        cin>>op;\n        if(op==1){\n            cin>>fa[i][0]>>a[i]>>c[i];\n            for(ll j=1;j<=20;j++)  fa[i][j]=fa[fa[i][j-1]][j-1];\n        }\n        else{\n            cin>>vi>>wi;ll ans1=0,ans2=0;\n            while(a[vi]&&wi){\n                ll fv=found(vi);\n                ll minn=min(wi,a[fv]);\n                ans1+=minn;a[fv]-=minn;wi-=minn;\n                ans2+=minn*c[fv];\n            }\n            cout<<ans1<<\" \"<<ans2<<endl;\n        }\n    }\n    return 0;\n}\n\n```\n\n  </code></pre>\n</details>\n\n## 倍增-思维好题\n[CodeForces 1335F](https://codeforces.com/problemset/problem/1335/F)\n\n[题意及思路转载](https://www.cnblogs.com/suxxsfe/p/12699630.html)\n\n一开始自己想的是有多少个循环节，先用dfs遍历出有多少个循环节，然后再数出所有循环节内个数，即为可放机器人个数。然后再枚举每个为0的点，看他对应循环节的哪个位置。。。很明显，这么写就纯模拟，而且很复杂。**然后因为我一直是按一个格子来思考，无论怎么想，都不会出正解。因为题目很明显表示出来格子之间是有影响的，不是相互独立的。如果我能够按两个格子一起走来思考，应该就不难想出来了。有些东西没考虑到，是不可能想出来的，比如这题不考虑其他格子的影响**\n\n```cpp\n\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-09-20 16:42:51\n*/\n#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\nconst ll maxn=1e6+11;\nll st[maxn][22],flag[maxn],cnt[maxn],d[111],n,m;\nchar grac[maxn],gras[maxn];\nvoid init(){\n    d[85]=-m;d[82]=1;d[68]=m;d[76]=-1;\n    for(ll i=1;i<=n*m;i++)  flag[i]=cnt[i]=0;\n}\nvoid out(){\n    ll ans1=0,ans2=0;\n    for(ll i=1;i<=n*m;i++){\n        if(cnt[i]>=1)  ans1++;\n        if(flag[i]==1)  ans2++;\n    }\n    cout<<ans1<<\" \"<<ans2<<endl;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll ca;cin>>ca;\n    while(ca--){\n        cin>>n>>m;\n        init();\n        for(ll i=1;i<=n*m;i++)  cin>>gras[i];\n        for(ll i=1;i<=n*m;i++){\n            cin>>grac[i];\n        }\n        for(ll i=1;i<=n*m;i++){\n            st[i][0]=i+d[(ll)grac[i]];\n        }\n        for(ll j=1;j<=20;j++){\n            for(ll i=1;i<=n*m;i++){\n                st[i][j]=st[st[i][j-1]][j-1];\n            }\n        }\n        for(ll i=1;i<=n*m;i++){\n            ll to=st[i][20];\n            cnt[to]++;\n            if(gras[i]=='0')  flag[to]=1;\n        }\n        out();\n    }\n    return 0;\n}\n\n\n```\n","tags":["基本算法","数据结构"]},{"title":"尺取","url":"/2021/08/26/尺取/","content":"\n游标卡尺真好玩\n<!--more--> \n# 尺取法\n## eMmmmm\n**适用条件**  单调性，区间长度递增，sum递增\n具体来说：对于判断条件k，区间长度递增，k也递增。\n例如判断条件为区间和sum时，区间长度递增，sum也递增。\n## 经典例题 最短子序列和>=s\n**题目链接**  https://vjudge.net/problem/POJ-3061\n**题意**  求一段最短的子序列之和>=s\n**思路** 跑尺取即可\n**核心代码** \n\n```cpp\nfor(int i=0;i<n;i++){\n    sum+=a[i];\n    length++;\n    if(sum<s){\n        continue;\n    }  \n    else{\n        while(sum>=s){\n            if(length<min)  min=length;\n            if(sum-a[l]<s)  break;\n            sum-=a[l];\n            l++;\n            length--;\n        }\n    }\n}\n```\n\n## 灵活运用\n**题目链接**  https://www.cnblogs.com/iiyiyi/p/5962512.html\n**题意**  求一段含负数的子序列之和的绝对值最接近t，输出该段子序列之和及左右端点。\n**思路** 与平常子序列之和不同的一点就是含有负数，如何处理负数的问题是关键。因为有负数，导致序列非单调，不能使用尺取法。所以我们需要转化一下，关键又是转化！！！所以我们可以发现这类题的关键都是转化一下数据形式，把数据处理成我们能处理的形式，即可！核心思路都是一样的！这里我们将其转化为前缀和，再将前缀和按升序排列即可跑尺取法了。\n\n## 灵活运用-结合Hash\n**题目链接**  https://vjudge.net/problem/POJ-3320\n**题意**  求一段最短序列包含所有知识点，知识点用一个整数表示，范围是到2^32\n**思路** 因为知识点范围很大，到2^32，所以我们需要将知识点Hash下，不然存不下，之后就是将知识点数量理解为尺取里的Sum即可。","tags":["基本算法"]},{"title":"并查集","url":"/2021/08/26/并查集/","content":"\n说！你跟他到底有没有关系？\n<!--more--> \n\n# 好题题单\n- [ ] [Path Queries](https://codeforces.com/problemset/problem/1213/G)\n\n# 并查集\n**并查集的本质是对传递性关系的维护**\n\n## 普通并查集\n初始化\n```cpp\nvoid init(){\n    for(ll i=1;i<maxn;i++)  fa[i]=i;\n}\n```\n路径压缩+查找\n\n```cpp\nll found(ll x){\n    return fa[x]==x? x:fa[x]=found(fa[x]);\n}\n```\n合并\n\n```cpp\nll fu=found(u),fv=found(v);\nfa[fu]=fv;\n```\n基础题：\n[小希的迷宫](https://vjudge.net/problem/HDU-1272)\n[Wireless Network](https://vjudge.net/problem/POJ-2236)\n\n## 带权并查集\n做这类带权并查集的题目，解决并查集中两两的关系时，可以用**向量**的思想来做。只要保证路径压缩时，a+b=c，那么这道题就可以放心大胆的用向量加减法来处理权值了。\n \n **关于权值di[i]的初始化**\n 对于权值di[i]，是需要初始化的，不过一般都是初始化为0，在定义其为全局变量时，就默认为0了，然后有时候就没写在代码里，但是要初始化的。\n## 经典题型1\n[食物链](https://vjudge.net/problem/POJ-1182)\n  题意 a吃b，b吃c，c吃a，求假话数量\n  思路：带权并查集，比如一句话包含a和b，判断a，b是否在同一并查集内，不在则合并，在则判断这句话是否正确即可。关键在于权值的设置，\n  这个权值的设置十分巧妙，**有向量那味**，但我还是不知道为什么能这样\n  感觉这个权值的设置是个巧合，刚好能这么做。\n **踩坑**：并查集合并一定是fa[fy]=fx，不能fa[y]=x;\n```cpp\nll found(ll x){\n    if(fa[x]==x){\n        return x;\n    }\n    else{\n        ll fx=found(fa[x]);\n        di[x]=(di[x]+di[fa[x]])%3;\n        return fa[x]=fx;\n    }\n}\n```\n## 经典题型2\n[How Many Answers Are Wrong](https://vjudge.net/problem/HDU-3038)\nTT 写一串数字，对 FF 不可见\nFF 选择一个区间（会重复操作）， TT 把这个区间的和告诉 FF，然额，一些和是不正确的（好狠心的女生），所以，有一些答案是矛盾的，根据这些矛盾求出答案错误的个数。\n注意两点：1。TT 给的一个 和 是正确的，如果它与之前给的 和 不矛盾。\n2。FF 发现一个与之前矛盾的 和 之后，该 和 不再参与之后的分析，直接被抛弃了\n**思路** 带权并查集，注意区间端点的设置，为了衔接,将[3,4]和[5,6]变为(2,4]。和(4,6]，这样子两边端点才能衔接上，才会在一个并查集里。\n\n基础题：\n[Navigation Nightmare](https://vjudge.net/problem/POJ-1984)\n\n## 灵活运用（带权并查集+hash）\n本题解决：\n1.hash后对并查集是否有影响\n2.并查集中子父结点的大小关系对结果的影响\n\n [Parity game](https://vjudge.net/problem/POJ-1733)\n**题意**：A有一段最大长度为1e9只含0和1的序列，B询问m次，m<5e3\n每次询问[l,r]之间1的个数，A会告诉他是奇数个还是偶数个\n但是A的回答可能是错误的，请判断A的回答从哪次开始矛盾\n\n**思路**：\n令a为子节点，b为父节点\n用权值1表示a到b含奇数个1，用权值0表示a到b含偶数个1\n虽然A的长度很长，有1e9，但B只询问m次,m<5e3，每次询问最多出现两个数字，所以最多1e4种数字\n所以我们可以将数字长度离散化，我这里是采用hash的方式，这里不用担心hash后会对程序有影响\n**因为这里hash只是将原数字映射到另一个数字罢了，hash(x)与x就为同一个数字,完全不会有影响**，\n这里进一步说明，hash(x)对程序是没影响的。\n本来输入是x和y，是x到y，x是小于y的，路径压缩时默认子节点是小于父结点的，\n**但存在一个问题,hash(x)可能会大于hash(y)，这样子会不会有影响呢？\n经检验，这里x,y两者大小关系，对运算无影响。因为如果是x>y,那么我们将其反过来，就相当于-w了**。\n那么我们的运算结果还是一样的，即0+1=0-1 0+0=0-0  1+0=1-0 1+1=1-1(每次运算记得模2)\n\n```cpp\n#include<stdio.h>\n#include<string.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")//解决递归函数多次调用栈溢出问题\n#define Debug(x) cout<<#x<<':'<<x<<endl\ntypedef long long ll;\n#define INF 0x7fffffff//10^9级别，不到2^32\nconst ll maxn=1e5+11;\n\n\n#define jump 10007//大概比mod小十倍\n#define mod 100003//\nll lib[mod + 2];//lib[x]记得初始化为数据中不会出现的数，比如这里为-1\ninline ll hash1(ll x){//返回x在哈希表中位置\n    ll num = x;\n    x = (x % mod + mod) % mod;//包含处理x为负数情况\n    while (lib[x] != -1 && lib[x] != num) x = (x + jump) % mod;\n    if (lib[x] == -1) {\n        lib[x] = num;\n    }\n    return x; \n}\n\n\nll fa[maxn],di[maxn];\nll found(ll x){\n    if(fa[x]==x){\n        return x;\n    }\n    else{\n        ll fx=found(fa[x]);\n        di[x]=(di[x]+di[fa[x]])%2;\n        return fa[x]=fx;\n    }\n}\nvoid init(){\n    memset(lib,-1,sizeof(lib));\n    for(ll i=0;i<maxn;i++)  fa[i]=i;//---------------------------为0！！！\n}\nint main(){\n    init();\n    ll n,q;\n    scanf(\"%lld%lld\",&n,&q);\n    ll ans=q,flag=0;\n    for(ll i=1;i<=q;i++){\n        ll u,v,w;\n        char ar[11];\n        scanf(\"%lld %lld %s\",&u,&v,ar);\n        if(flag==1)  continue;\n        if(ar[0]=='e')  w=0;\n        else  w=1;\n        u-=1;\n        u=hash1(u),v=hash1(v);\n        ll fu=found(u),fv=found(v);\n        if(fu==fv){\n            if((w+di[v])%2==di[u])  ;\n            else{\n                flag=1;\n                ans=i-1;\n            }\n        }\n        else{\n                fa[fv]=fu;\n                di[fv]=(w+di[u]-di[v]+2)%2;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n```\n## 灵活运用（贪心+并查集）\n[Supermarket ](https://vjudge.net/problem/POJ-1456)\n这里其实用贪心做，并查集只是用来作为工具，使得速度更加快。\n**这道题解决**：  用并查集以O(1)找到最近的非空点\n**题意**是买卖N件东西，每件东西都有个截止时间，在截止时间之前买都可以，而每个单位时间只能买一件。问最大获利。\n\n**思路**如果购买不冲突，那么全部买下来就可以了。存在冲突，就需要取舍。显然在冲突的时候我们选择价格高的更优，如此就可以用贪心的算法。先将物品按照价格从高到底的顺序排列，购买一个就在时间点上做一个标记，只要不冲突就可以购买。 如何快速找到第一个不冲突的时间点呢，个人感觉使用并查集很好得解决了这个问题。用并查集维护当前节点最近的空闲点即可。每当一个位置i被选中就将当前节点的父节点更新为i-1，查询时只要父节点非零就证明有空闲位置，选中更新输出答案。\n\n```cpp\n/*\n\n*/\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=10010;\nint F[MAXN];\nstruct Node\n{\n    int p,d;\n}node[MAXN];\nbool cmp(Node a,Node b)//按p从大到小排序。d没有关系\n{\n    return a.p>b.p;\n}\nint find(int x)\n{\n    if(F[x]==-1)return x;\n    return F[x]=find(F[x]);\n}\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n)==1)\n    {\n        memset(F,-1,sizeof(F));\n        for(int i=0;i<n;i++)\n          scanf(\"%d%d\",&node[i].p,&node[i].d);\n        sort(node,node+n,cmp);\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            int t=find(node[i].d);\n            if(t>0)\n            {\n                ans+=node[i].p;\n                F[t]=t-1;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n## 灵活运用（连通块，并查集）\n[path queries](https://codeforces.com/problemset/problem/1213/G)\n  题意 有m次询问，每次询问一个数字q，问以u,v为端点的路径的最大值不超过q的u，v对有多少个\n  思路：考试时想了很久，由于没有考虑过连通块，之前也没碰到过。。\n  导致一直做不出来，就是感觉能做，但一直没做出来\n  首先我们要知道，对于两个不相连的连通块，如果将他俩连起来，\n  是需要一条边将这两者连起来的，如果这条边是这两个连通块的所有边的最大值,那么以这条边为最大值的u,v就有size[a]*size[b]个。\n  那么我们将所有边按从小到大排序，这样子保证新加入的边是目前边的最大值，即两个连通块的最大值,连通块则用并查集处理。\n \n 贴一个极简风格的大佬代码，真的是绝绝子\n [原大佬代码链接](https://blog.csdn.net/weixin_43826249/article/details/105979123?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162968700116780262582181%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162968700116780262582181&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-105979123.pc_v2_rank_blog_default&utm_term=path&spm=1018.2226.3001.4450)\n\n```cpp\n#pragma GCC optimize(\"-Ofast\",\"-funroll-all-loops\")\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=2e5+10;\nint n,m,res[N],ans,f[N],sz[N];\nvector<pair<int,int> > v[N];\nint find(int x){return x==f[x]?x:f[x]=find(f[x]);}\nsigned main(){\n\tcin>>n>>m;\n\tfor(int i=1,a,b,c;i<n;i++)\tscanf(\"%lld %lld %lld\",&a,&b,&c),v[c].push_back({a,b});\n//在for里面就把a,b,c给定义了\n//这里用vector存边不得不说很巧妙，v[c]代表以c为权值的边集合,\n//再用pair存边的两个端点，不得不说这数据结构设计得十分牛掰\n\tfor(int i=1;i<=n;i++)\tf[i]=i,sz[i]=1;\n\tfor(int i=1;i<=2e5;i++){\n\t\tfor(auto j:v[i]){//这个我也表示学到了学到了\n\t\t\tint x=find(j.first),y=find(j.second);\n\t\t\tans+=sz[x]*sz[y];\tf[x]=y,sz[y]+=sz[x];\n\t\t}\n\t\tres[i]=ans;\n\t}\n\tfor(int i=1,x;i<=m;i++)\tscanf(\"%lld\",&x),printf(\"%lld \",res[x]);\n\t//在for里面定义变量x，这样子就不用在scanf前面加一行x的定义了\n\t//学到了学到了\n\treturn 0;\n}\n\n```\n\n## 带权并查集好题\n[Jumping Monkey HDU - 7136 ](https://vjudge.net/problem/HDU-7136) \n\n题意：一个n<1e5的树，每个点有个权值w，从u点能走到v点当且仅当v是uv这条路径上的最大权值，求每个点可以到达的点的个数。\n\n\n<details>\n  <summary>点击查看思路</summary>\n  <pre><code>  \n\n![](/uploads/并查集/2021-10-10-21-49-43.png)\n\n也可以用带权并查集维护这个过程，当按点权从小到大枚举结点u,并将u作为所有与u相连的（已经枚举过的）连通块的根时，\n我们让fa[ fv ]=fu,d[ fv ]=1;并查集合并时则使d[ x ]=d[ x ]+d[ fa[ x ] ],和树的深度是一个意思。\n\n  </code></pre>\n</details>\n\n```cpp\n/*\n* @Author: Marhoosh\n* @Date:   2021-07-22 10:27:29\n* @Last Modified by:   Marhoosh\n* @Last Modified time: 2021-10-10 19:04:19\n*/\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n#define Debug(x) cout<<#x<<':'<<x<<endl\n#define INF 0x7fffffff\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll maxn=2e5+11;\nll head[maxn],to[maxn],nex[maxn],var[maxn],d[maxn],fa[maxn];\nll tmp,n;\nP po[maxn];\nvoid add(ll u,ll v){\n    to[tmp]=v;nex[tmp]=head[u];head[u]=tmp++;\n}\nll found(ll x){\n    if(fa[x]==x){\n        return x;\n    }\n    ll t=found(fa[x]);\n    d[x]=d[x]+d[fa[x]];\n    return fa[x]=t;\n}\nint main(){\n    ll ca;scanf(\"%lld\",&ca);\n    while(ca--){\n        tmp=1;\n        scanf(\"%lld\",&n);\n        for(ll i=1;i<=n;i++){\n            head[i]=0;fa[i]=i;d[i]=0;\n        }\n        for(ll i=1;i<=n-1;i++){\n            ll u,v;scanf(\"%lld%lld\",&u,&v);\n            add(u,v);add(v,u);\n        }\n        for(ll i=1;i<=n;i++){\n            scanf(\"%lld\",&var[i]);\n            po[i]={var[i],i};\n        }\n        sort(po+1,po+1+n);\n        for(ll i=1;i<=n;i++){\n            ll u=po[i].second,w=po[i].first;\n            for(ll j=head[u];j;j=nex[j]){\n                ll v=to[j];\n                if(var[v]>w)  continue;\n                ll fu=found(u),fv=found(v);\n                fa[fv]=fu;d[fv]=1;\n            }\n        }\n        for(ll i=1;i<=n;i++){\n            found(i);\n            printf(\"%lld\\n\",d[i]+1);\n        }\n    }\n    return 0;\n}\n\n```\n","tags":["数据结构"]},{"title":"单调队列、栈","url":"/2021/08/26/单调队列、栈/","content":"\n区间！最近！最值！\n<!--more--> \n\n\n# 单调队列 单调栈 尺取法\n## Mmmm\n**1**单调栈和单调队列一般用来求最近小，求最远小不能直接求，得结合二分\n**2**单调队列和单调栈区别不大，或者说单调队列是包含单调栈的，其主要区别在于，单调队列可以在队头进行操作，即可以在一段区间的左边界进行相应操作，而单调栈不行。即对于一段子区间来说，单调栈只能变化子区间的右边界，而单调队列可以变化左右边界。\n**3** 单调队列维护的区间范围是【队头，当前元素】，也就是说单调队列只能控制当前元素到左边的范围。如果题目要求控制当前元素两端的范围，比如-D<=x<=D，那么就得跑两遍单调队列，从左到右跑一遍，再从右到左跑一遍。\n## 单调队列\n**1**单调队列主要用于解决左端点可移动的区间最值问题。\n### 经典例题，固定区间长度\n**题目链接**  https://vjudge.net/problem/POJ-2823\n**题意**：给一个固定长度的滑动窗口，输出窗口内的最大值和最小值\n**思路**：跑单调队列即可\n**核心代码**\n```cpp\nfor(int i=0;i<n;i++){\n        while(!dq1.empty() && i-dq1.front().x+1>k)  dq1.pop_front();\n        //维护区间左端点\n        while(!dq1.empty() && a[i].n<dq1.back().n)  dq1.pop_back();\n        //维护区间右端点\n        dq1.push_back(a[i]);\n        if(i-k>=-1)  printf(\"%d \",dq1.front());           \n    }\n```\n\n### 经典例题，区间长度变化--结合尺取\n**题目链接**  https://vjudge.net/problem/HDU-3530\n**题意**：找一段最长连续子序列，其最大值减最小值的差满足差>=m且<=k\n**思路**：与固定区间长度不同的是，此区间长度是变化的，故需要结合尺取法。需注意尺取法求区间和只能判断一个边界，而此题有两个边界，要求m<=区间和<=k,所以我们只取边界k，把>=m作为条件，以k为边界，在满足区间和<k的情况下，再判断是否满足>m即可。\n**核心代码**\n```cpp\n  for(r=0;r<n;r++){\n      DqmaxPushB(a[r]);\n      DqminPushB(a[r]);\n      length++;\n      d=dqmax.front().n-dqmin.front().n;\n      while(d>k){\n          if(!dqmax.empty() && a[l].x==dqmax.front().x)  dqmax.pop_front();\n          if(!dqmin.empty() && a[l].x==dqmin.front().x)  dqmin.pop_front();\n          l++;\n          length--;\n          if(dqmax.empty() || dqmin.empty()){\n              d=0;break;\n          }  \n          else  d=dqmax.front().n-dqmin.front().n;\n      }\n      if(d>=m)  if(length>maxl)  maxl=length;\n  }\n```\n### 灵活运用\n**题目链接** https://www.luogu.com.cn/problem/P3088\n**题意**  如果在x左右为d的范围内，有>=2*x的数，那么我们称x为拥挤的，求一数列中拥挤的x的数量。\n**思路**  乍一看，求2*x作为最大值对应的区间？好像跑个单调栈就出来了，但一上手发现不行，因为他要求的是两倍x，而我们单调栈中对应的是每个原数x，不是2*x，所以用单调栈不行。这道题是有两个区间，-d和d，但单调队列只能维护一边的区间，所以我们跑两次单调队列就可以了，从左到右一次，再从右到左一次。\n\n### 灵活运用，求最远小\n**题目链接**  https://vjudge.net/problem/CodeForces-91B\n**题意**  一个数列，求每个数之前的最远的那个小于它的数与它之间有多少数，若无则输出-1.\n**思路**  一般单调栈用来处理最近小，这个是最远小，但不过没关系，我们还是可以维护一个单调递减栈，对于每个元素，①如果其>=栈顶，则不入栈，因为小于它的数，肯定在前面；②如果其<栈顶，则入栈，输出-1\n\n### 灵活运用，结合循环右移-倍增\n**题目链接**  https://vjudge.net/problem/HDU-4193\n**题意**  给一个长度为n的数列，循环右移k次，1<=k<=n-1，问有多少次右移的所有前i项和>=0。\n**思路** 这题自己想的，结合自己整理的这篇文章，理清脉络，并不难想。~~真想夸自己聪明，毕竟这是隔了很久才自己做出来一道有挑战性的题目了，平常都是看题解，终于自己也聪明了一回~~ 所有前i项和>=0嘛，转化下，常用数学思想，就是最小值>=0。循环右移k次，可以用倍增法，即倍增数组，也就转化为在2*n长度的数组上，求固定长度为n的区间的最小值>=0的区间有多少个。数据处理方面，可以2*n的数组为前缀和，最小值再减去区间前n项和就是当前区间最小值了。就是裸的固定长度单调队列了。\n## 单调栈\n### 经典例题，求最值及其对应区间\n**题目链接**  https://vjudge.net/problem/POJ-2796\n**题意**：求子序列之和乘以子序列的最小值的最大值\n**思路**：单调栈经典题型，枚举n个最小值，以及其对应区间和。单调栈具体的实现就是弹栈时，其对应的栈中上下两个值即为边界。代码处理细节，加个栈底值和栈顶值，保证所有值都有左右边界，且都出栈。\n**核心代码**\n```cpp\nfor(ll i=0;i<=n+1;i++){\n    while(!st.empty() && ar[i].n<=st.top().n){\n        t=st.top().n;\n        st.pop();\n        l=st.top().x;\n        r=ar[i].x;\n        sum=Sum[r-1]-Sum[l];\n        //cout<<r<<\" \"<<l<<endl;\n        //cout<<sum<<\" \"<<t<<endl;\n        mul=sum*t;\n        if(mul>=maxmul){\n            maxmul=mul;\n            minl=l;\n            maxr=r;\n        }\n    }\n    st.push(ar[i]);\n}\n```\n### 灵活运用\n**题目链接**  https://blog.csdn.net/zuzhiang/article/details/78136417\n**题意**  求仅由0，1组成的矩阵中，全部由1组成的子矩阵的最大面积。\n**思路** 这道题需要先预处理下数据，因为它是全部由1组成的矩阵，所以需要连续的1，故我们把连续的1转换成长度表示最好，这样子就十分直观。剩下的就是以每行为底，求以每列为宽对应的区间即可，即转化为求最小值及对应区间问题。\n\n### 灵活运用，维护最小值单调栈\n**题目链接**  https://darkbzoj.tk/problem/1113\n**题意**  许多个高度不等的矩形排列在一起，问最少用多少个矩形可以将其全部覆盖\n**思路** 什么时候能少用一个矩形呢，那就是当在这个矩形之前，有个高度跟他一样的矩形，且这两个矩形之间的高度都要高于他才可以。故维护一个最小值单调栈即可\n**核心代码**\n\n```cpp\nfor(int i=0;i<n;i++){\n    while(!st.empty() && st.top()>h){\n        st.pop();\n    }\n    if(!st.empty() && st.top()==h)  ans--;\n    st.push(h);\n}\n```\n","tags":["数据结构"]}]